= Memi Lavi
:toc: left
:toclevels: 5
:sectnums:
:sectnumlevels: 5

NOTE: NOTE

TIP: TIP

IMPORTANT: IMPORTANT

CAUTION: CAUTION

WARNING: WARNING

[cols="1,3"]
|===
| Name | Description

| Asciidoctor
| Awesome way to write documentation

|===

== The Complete Guide to Becoming a Software Architect : Memi Lavi

* *History*
** I did this earlier while preparing for Interviews
** Doing it again for Job change / Becoming Architect

* *Agenda/Iteration 2*
** Started using the following
*** Anki

** Pending Use
*** Visual Markers
*** Association
*** Link System
*** Mind Maps
*** Peg System

* *Summary*

=== Section 1: Welcome

==== Introduction

Hello and welcome to The Complete Guide to becoming a software architect cause a few years ago I had a meeting with a potential client. The meeting took place in his office at a thirty fourth floor in one of the skyscrapers in the city. He began the meeting by asking me, Tell me me, why do I need a software architect? I have a talented group of developers and a great I.T. department. Isn't that enough for building great software? I thought for a second and then told him, what would you do if I told you this building we are sitting in had no architect involved in its design and construction process. The workers came in every morning, put the cement tucked in the steel beams and went home. He looked at me for a few seconds, then jumped from his chair, got in the nearest elevator and ran for his life. Well, OK, he didn't really do that, but he did tell me, OK, maybe now I get it. And what about you? Do you want to be a software architect? Do you want to know what it means to be a software architect? Do you have no idea about software architecture whatsoever? Or maybe you just want to be a much better developer. You you've come to the right place. Software architect is one of the most interesting, rewarding and challenging jobs in the software industry and in these schools. I'll teach you everything you need to know in order to become one, a great one. This is a practical, experience based, comprehensive course that will guide you step by step towards becoming an exceptional software architect. Throughout this course, we will discuss not only high level principles, but also real world examples down to earth techniques and soft skills required for this job. This is a really back course. It contains a lot of materials, all stem from my experience of 15 years as an architect. If you fill a specific lecture is not clear enough, do not hesitate to contact me via the Q&A button. I promise to answer any question, but that's not all. Towards the end of this course, you will be able to download a real practical Sotho architecture document, which is the heart of every software architects work. You are more than invited to read it, learn from it and even use it in your own projects. Just fill in the blanks and you are good to go. Now, for those of you who don't know me, nice to meet you. My name is Mimi Lovey and I'm a software architect with fifteen years of experience. I've worked with large enterprises, big multinational companies, start ups and lots more. My technology stock is quite diverse and includes, among others, dot net, Java, Python, SQL Server, Oracle, Modiba, react, angular, azure, a little bit of awareness and lots more. I've had my fair share of successes as well as some painful failures. I always try to learn from my and others experience and during the years I've developed a simple and practical architectural process which I've been using in a lot of projects. But enough about me. Let's talk about you.

==== Who Is This Course For?

So who is the perfect audience for this course in order to benefit the most from this course, you must have some background in programming. It doesn't really matter which platform you're currently programming with. It could be Java dot net or anything else they would be coding in this schools. However, this course might not be a good fit for general developers who take their first steps in the programming world. We will be discussing some advanced software principles which jula developers might not be aware of, and this might make it more difficult for them to grasp the concept described in this course. In addition, it would be better to have some back and experience both architectural dilemmas present themselves in the backend where performance, security, caching and other considerations are extremely important. So to sum it up, the perfect audience for this cruise is someone with three years of experience as a developer with back in development experience. However, anyone with some development experience will benefit from this course. And you are more than invited to contact me regarding any question you have about these cruise material.

==== Why You Should Become a Software Architect

Before discussing the whole let's talk about the way, why is it a good idea to be a software architect,  what's so attractive about it?  Good question.  There are three very good reasons to be a software architect.

*One*, this is a really, really very interesting job.  As a software architect, your daily routine may include talking to CXO that CIOs, CFOs, CEOs in  the mall, discussing technology with development manager and conducting some research about new patterns  and platforms.  There truly is no other role in the software industry, which is as diverse, broad and spread across  the whole organization as the role of the architect, as we will see later in this course.  Good architects work in both business, technology, methodology, soft skills and the more I can promise  you this as an architect, you are not going to get bored ever

Reason number *two* career path and visibility,  being an architect to communicate with all levels of the organization that will make you quite visible  to management and will pave the way to future promotions.  One of my friends was a developer for five years and felt it's time to move on.  He wasn't sure what kind of job to look for, and knowing him and his abilities, I recommended him  to look for a junior architect position.  After a couple of weeks, he landed a job and was amazed by the amount of communication he had with  the CEO and CIO of the company.  Today, he's a senior architect in one of the largest companies on the planet.  So, yes, being a software architect can definitely push your career forward.

Reason number three, *money*.  Everyone wants it, but few are ready to talk about it.  But take a look at these numbers.  As you can see, the average salary of an architect is almost double the salary of a developer here.  And just be quiet for a few seconds while you're crunching the numbers.  But honestly, you should not go for the money.  A good architect is someone who loves what she does.  You should love the challenge, enjoy the discussions, embrace the research, and only then think about  the money.  So to recap, here are the three reasons to be an architect and believe me, these reasons are real.  If you're looking for an interesting, promising and rewarding role.  Go be a software architect.

==== What We Will Talk About in This Course

image::memi-levi/agenda.png[]


So what are we going to talk about in this course? Well, we are going to cover a lot of materials. First is a welcome section, which we are in right now. Then we'll talk about the definition of a software architect. As you'll see, there are several types of architect will describe some of them and then focus on the types that really interest us, this software architect. Then we will discuss what is perhaps the biggest change in software architecture do in order to bring the maximum benefit to the organization, adopt a business mindset instead of a technological one. We'll talk about the meaning of this mindset and why it's so important for the architect. The fourth fiction in this course outlines the architecture process. What are the actual steps the architects should take in order to build a robust, practical architecture for the system? She's walking on the next sections deep dive into this process and detail the specifics of each step. They're walking with system requirements section talks about the importance of fully understanding the system requirements and introduces us to the concept of non-functional requirements. After we have discussed the requirements, we will turn our attention to the application itself. The first thing an architect should do is define the type of the application, and in this section we will explore the various types of mainstream application types and what are the main attributes of each type. After we have decided on the application type, it's time to select a technology stack. In this section, we will discuss the various considerations for selecting technology stack and explore various implementation options for front end backend and data store. Having selected the technology stack, it's time to start talking about the architecture. But wait. Before discussing architecture, we need to meet a set of capabilities that will help us design an architecture that fulfills the non-functional requirements. And in order to fully understand the functional requirements, we will meet this tonalities. No, they are not a family of weirdos, but a set of nonfictional requirements every architect should know about and make sure her architecture is well suited for them. And now it's time to start looking at the components of the applications, components of the building blocks of almost every application, and they must be designed correctly in order to ensure the application is fast, efficient and easy to maintain. In this section, we will deep dive into the attributes of a well-designed component. Note, this is going to be a little bit low level, but it's a must for every architect to be able to look at the code without feinting. The next section is an introduction to design. You probably heard of design patterns already, but even if not, don't worry. We will discuss the idea behind the design patterns and delve into some of them. Having talked about the micro level of the system, it's time to take a step back and look at the macro level as a system, as a whole, in order for a system to be reliable, first secure and easy to maintain. It's important to take into consideration both attributes of a well-designed system. We will discuss those attributes and understand how they affect the architecture. Every seasoned architect knows that architectural decisions are really made on a technical basis. There are always other considerations and constraints that must be taken into account. In the next section, we will explore the most common constraints and see how they might affect architecture. And then drumroll, please, we arrived. What is perhaps the most important section in discourse, the architectural document. This document is a combination of the architectural process. It is the product of the requirements, technology, components, architecture, systems, architecture, external considerations, coffee saturated meetings and long silent writing session. The document describes the architecture design for the system and contains everything the developers and team leaders need to know in order to start developing. The system in this section will go through the documents, goal audience and structure and discuss the content of each section in the document. After we have talked about the document, it's time to put everything we talked about to test. In the case study section, we will discuss the system we need to design for a fictional company, we will go together through all the steps we talked about, understands the requirements, decide on the technology stock map and designs the various components and talk about the architectural document structure. At the end of this section, you will find a very special bonus and architecture document, complete with all the sections discussed in this course ready for you to download and use. You can use it as a template for your future document or as a reference for your own document. But anyway, it's your views. Enjoy it. The software architecture is a moving, vibrant world, and there are always new trends in advances. The next section explores some advanced architectural concepts, such as medical services, securest and even sourcing. Don't worry if you don't know what this means. I'll explain it all. In the last but not the least of this cross section deals with soft skills, a good architect must practice her soft skills. You need to know how to speak to people, how to listen, what to do with criticism. And you will get a lot of this, how to deal with organizational politics and more. The soft skills section deals with those topics, and I encourage you to pay close attention to it. This might be exactly what will make you a great architect. And after all, this will conclude and reflect on what we have learned together, so brace yourself for the fascinating world of software architecture. And let's go.

=== Section 2: What is a Software Architect

==== Types of Architects

So what is actually a software architect, what is his objective, what is he actually doing?  Who is he working with?  Will, all these questions are great, but before we will answer them, let's discuss other types of  architect who was the architect in the software world is an overloaded one.  There are quite a few types of architects.  And let's take a look at the most common ones, which are infrastructure architect, software architect  and enterprise architect.  There are some more types of architects, but they are more finished and we want to talk about them.  So let's see what those types of architects are.

First *infrastucture architect*.  The infrastructural architect is responsible for designing the infrastructure of a given system, and  by infrastructure, I mean all the non software related elements such as servers, virtual machines, network  storage, etc. He's responsible for all this and also to make sure they work nicely with the system,  developed the infrastructure architecture to be familiar with the systems requirements so he can make  sure the infrastructure he designs will support those requirements.  For example, if the system is expected to grow by three terabytes annually, the infrastructure architect  should make sure the storage for the system will be able to handle this load.  The career path for infrastructure architect goes through infrastructure experts.  You have to be well versed in infrastructure, design, implementation and configuration in order to  become a good infrastructure architect.

Next, the software architect, the *software architect* sometimes called also solution architect or system  architect, is responsible for the architecture of the software, since you will be dealing with a software  architect for the rest of this course.

I'll skip to the *enterprise architect*, the enterprise architect works, with the top management of  the organization to *make sure the IT of the organization is an enabler for the business and not a  hindrance*.  In many organizations, business decisions such as starting a new sale or entering a new business field,  is held back by the IT, which needs time to adapt to the new requirements.  *The enterprise architect usually walks with the CEO and CIO of the organization to find out what are  the main bottlenecks, what holds back the waiting and how it can be streamlined to support business  continuity.  Since the enterprise architect operates at a very high level in the organization, he has almost no  work relations with development oriented roles such as developers and team leaders.  #In order to become an enterprise architect, one has to be first a senior software architect or an experienced  project manager.  As I said earlier, the enterprise architect is not very technical, and you don't always have to have  a practical hands on experience in order to become one, although it's definitely a plus#*.  Great.  So having discussed other types of architects, let's meet our protagonist, the software architect.

---

*Responsibility of the Architect*

So let's talk about the responsibility of a software architect, one of the questions I often asked is what is the difference between a senior developer and an architect? After all, in a lot of companies, mainly small ones, there is not a function of an architect, just a team leader. What do we need an architect at all? #The short answer is this developer knows what can be done. Architect knows what should be done.# A senior developer knows the technology very well, knows what is the best way to implement loops, how to perform operations efficiently, what libraries to use to access a database, and so on. *A software architect is also quite familiar with the technology platform, although not as much as a developer. But his main goal is to make sure the software design implements the requirements of the system. He's less interested in his implementation details of the system. This is a developer's job. The architect looks at the macro level, infuses the technology with the requirement*.

*Baseline Requirements:*

* Fast
* Secure
* Reliable
* Easy To Maintain

We'll talk a lot about requirements later in this course, but let's lay the foundations for the requirements of almost any system in these are first secure, reliable, easy to maintain. In almost every system I've been involved, *this list was the holy grail of the architecture*. This is what the architecture was made for, to make the system first secure, reliable and easy to maintain. Of course, every system has its own definition of those items. First, in a world of application working with satellites, telemetry is not the same fast of a traditional information system geared towards end users. Likewise, reliability of mission critical application, which must have an uptime of 99, not 99 percent, is not the same as reliability of a charter application of a support system which would be available only during normal working hours. But still, this list is usually the defining list of every architecture. *Now it's important to note that this list has nothing to do with technology, architectural patterns or platforms you don't see here using micro services based architecture or use Java or don't use relational database*. That's because a good architect knows the technology patterns and all the other buzzwords just means to the end result. *The technology should serve the requirements and not the other way around*. So to summarize, a software architect is someone who designed the system to be fast, secure, reliable and easy, to maintain and select the optimal technology platforms and patterns to achieve these goals.

*The Architect in the Organizational Chart*

image::memi-levi/org-chart.png[]

---

==== Architects & Code

One of the most heated argument in the architecture community is whether an architect should code like really code with an idea, debugging, logging, etc. Of course, the question is not whether an architect should participate in the development effort and be one of the development team. Of course, he shouldn't do that. The question is whether an architect should have coding skills that will allow him to test new technologies, create policies or demonstrate some concepts in code. Those who claim an architect should not be coding say that he has more important things to do than punching the keyboard and producing a few lines of code. He will better be producing patterns requirement in documents, say, and they have a point, but and I'm sorry to say that they are wrong. A good architect must have coding skills. And here are the three reasons for that. Architectural trustworthiness as an architect. You are going to design an architecture which utilizes certain platforms in patterns, you have to make sure the architecture is feasible and the best way to do it is to try and implement it yourself. Yes, that's not a mistake. You have to be able to implement certain parts of the architecture in order to test them before expecting the developers to implement the unimplementable. Yes, that award, for example. Are you going to recommend using a certain dependency injection package tested in a small application and make sure it's actually do what you expect it to do? Are you contemplating whether to use analytical database or stick with a traditional RDBMS? No problem, installed both on your machine and test them out. This is the only way to make the architecture trustworthy by testing it beforehand to ensure your design can be implemented effectively and easily support the developers. One of the hardest tasks of the architect is to make sure the architecture is actually implemented. The best way to do that is to provide an ongoing support to the developers. The architect must be able to help developers when they get stuck while implementing the architecture and Ximenes, the developers work to detect deviations from the intended implementation. If the architect does not possess coding skills, he won't be able to review the code and locate those deviations. Gain respect, one of the key factors to succeed as an architect is to gain the respect of the developers. If the architect is perceived as someone who has no idea what the developers are actually doing, they will think of him as a snob, arrogant and detached, and will immediately lose respect for him. If, on the other hand, they will see you sitting with them, helping them solve problems and listening to them, they will appreciate you as a down to earth practical and an all around nice guy and will be more than happy to listen to you in the future and discussing architectural topics and tasks. But you can't really help developers if you can't, aren't you? So to summarize, keep going. After all, it would only help you create a trustworthy architecture, provide an ongoing support and gain the respect of the developers. It also fund.

=== Section 3: The Architect's Mindset

==== Introduction to the Architect's Mindset

Welcome to the third section of this course, architects mindset, in this section, we will discuss  one of the most important aspects of being an architect, which is the architects mindset.  If your current job is a technical one, such as a developer or a team leader, then you are probably  thinking about the work you do for recording and development point of view.  But as you will see in this section, this is not always the most appropriate point of view for an architect.  The architect should often make a decision based on other factors which are sometimes for rent for developer.  *#But in order to be a really good architect, you have to adapt yourself to the new point of view, which  will make you a real asset for the organization#*.  So let's talk about this new mindset.

==== Understand the Business

The biggest mindset change you have to make in order to be a good architect is to *understand the business  your client or employer is involved in*.  Now, this might sound trivial.  Supposedly, everyone in the organization know what the company is doing, right?  Well, that's usually only partly true.  I'm sure every Microsoft employee knows that Microsoft developed software such as Windows and Office  in that it has one of the largest public clouds in the world.  I'm also sure that every Amazon employee knows that Amazon sells a huge selection of items from books  to fresh food.  But that is not enough.  And let me tell you a story.  A couple of years ago, I was approached by a company in the Beautiful.  It was a medium sized company with about 600 employees worldwide.  I was familiar with this company and I knew vaguely what it was doing, but I knew it wasn't enough.  So I grabbed my PC and began reading the day after we had the meeting.  To the surprise, I was able to tell them about the founders line of product, revenue and profit.  And bear in mind, the company was not publicly traded at that time, the competitors and so on.  This blew them out of the water and we agreed to work together on this very day.  But I must tell you this story to get you marketing tactics, although it's a very effective one.  The really important lesson here is that *in order to be of any value to the organization, you have  to have a deep understanding of the organizations business*.  You have to know *what keeps the CEO awake at night*.  You have to understand what its *weaknesses and strengths are*.  *Who are they competing with in what is a growth strategy*?  All you have to understand all this.

You can start talking architecture and technology.  *One of the most common mistakes made by architects is that they are looking at the systems they are  working on as a stand alone system, isolated from the rest of the organization*.  But it can't work that way.  Every organization is a living organism with a lot of moving parts, and the architect must understand  how the system integrates into this living organism.  And what role does this play?  So to recap.  *Remember, always understand the business before you begin walking on the architecture*.


==== Define the System's Goals

After we have understood the business and learned all there is to learn about it, it's time to look  at the specific system we are going to work on.  *The first thing to look at are the systems goals.  Now, it's important to note we are not talking here about what the system should do.  These are not goals.  These are requirements*.  And it's important to distinguish one from the other when talking about goals.  *We are talking about the effect the system will have on the organization.  This effect can be almost anything, but it should be clear how this will affect the bottom line of  the organization.  The reason we should be fully aware of the system's goals is that as architects, we must always think  about the big picture.  We must know what is the environment our system is going to be operating in and what are the main tasks  it is going to tackle.*  Usually the client should tell you what the system's goals are, but it is not always the case.  I once had a client that asked me to design the architecture of a specific system.  For him, the system specifications were clear, the value services and screens were already defined  and it looked like an easy task.  However, when we began discussing the place of the system in the organization, we found out almost  no one was going to use the system as it is.  There was many other systems which performed similar tasks, albeit in the less comfortable manner.  But the users were already used to those systems and there was simply not a strong enough incentive  for them to move to the new one.  We ended up changing almost all of the systems.  Scope and functionality in the final product was a much smaller but much more focused and effective  system.  Let's take a look at some examples of goals.  First, knew our system for a product oriented company.  The goal is to streamline the recruitment process, thus attracting better candidates.  This, of course, will help the company build better products more quickly, thus growing the revenue  two new information system for reporting and mapping criminal incidents in the city.  The goal here is to improve the police response time for every incident and to encourage new residents  to migrate to the city.  Of course, there is also a hidden agenda here.  This system will help them to be re-elected in the next elections.  Next, mobile application for flash sales, the organization who is a small and young startup with only  three developers.  The goal here is twofold.  One, your money as fast as possible and to attract investors.  OK, so we've talked about the system goes in, let's go on to another important aspect of the system,  which must be the architect mind.

==== Work for Your Client's Clients*

One of the most important aspects of the architects work is to identify who the client is.  Now, that may sound a little stupid.  Of course, I know who my client is.  It's the one who pays me well.  Yes, but also no.  Let me explain.  In almost every organization, the architect is part of the IT department.  It doesn't matter what the architect is an employee of the organization or a consultant who works with  the organization.  He's hired by the people.  But the I.T. guys have clients.  And these are the end users of the application and these are the guys you should work for.  What does it mean?  *It means that your mindset should be geared towards your client's client*.  It means that with every decision you make, you must ask yourself what will be the effect of this decision  on your client client?  It means that the comfort of your client's client is prioritized over the comfort of your client.  Let's see an example.  One of the recent systems I worked on was a systems that display data based on the telemetry received  from remote stations.  All of the dilemmas we had is what to do with the database during telemetry is offline.  This was a scenario we had to consider.  Some selected department could not commit to a concrete display of the database.  The solution we came up with was to display a clear message to the end user that there is a problem  with the system and ask him to try again later.  This is quite a common behavior for such a scenario.  However, the client asked whether we can find an intermediate solution that will allow him to use the  data but not make any modifications.  We thought about it long and hard and came up with a solution that made architecture much more complicated.  We have introduced a dedicated caching layer that duplicated the data.  It was used when the database was offline.  My client, which was a development team, worked much harder.  But my client's client, the end user, was extremely satisfied with this solution and praised our willingness  to help him and think outside the box.  Now, you might say that walking with a client is a systems analyst job and not the architect.  *This is usually correct, but sometimes a project is carried out without a system analyst on board.  And even if there is one, you still have to understand the client's environment in order to make the  best decisions for him*.  In this case, the architect does not replace a system on the list, but it's a very good idea to join  her for some meetings and to meet a client personally.  Sometimes you see that your client, the IT department, does not use a client as a client, they will  refer to the end users as colleagues, co-workers, or even those annoying guys that always have demands.  In this case, your work might be a bit harder.  You have to not only change your mindset, but also them

==== Talk to the Right People with the Right Language

Another important aspect of the architect's job is to know how to speak to different persons in the  organization.  Here is the rule of thumb, always keeping in mind what is the thing that really matters to the person  you are talking to.  If you can adapt to language to the best interests of the person we are talking to, you will be able  to achieve much more.  By the way, this will is right not only for architects, of course, but for anyone who tries to achieve  something for someone.  Let's look at some examples.  *Here is Sophie, the project manager.  Sophie, because only for the project success, she doesn't care what technology will be used or how  amazing the architecture is.  When you talk to her about your plans for the architectural, always emphasize how it will contribute  to the project's success*.  Avoid sentences like this is the latest and greatest pattern and will be the first to test it out.  We can write a blog post about it.  This sentence will only frighten her and she will immediately imagine how this untested technology will  cause delays and compromises down the road.  Instead, try something along the lines of this.  *New technology can help us write the code twice as fast so we can cut our schedule and budget accordingly*.  This is a language a project manager understands, and she will be more than happy to help you, assuming  you are right.  Of course.  Now let's look at the team leader.  That is a hard core geek and he just loved programming.  He spent at least one hour every night reading through technical blog posts, and he always up to date  with the recent development in software industry.  If you want to bring Dave on board and make him a strong proponent of your architectural talk to him  using a technical language, tell him.  Listen, Dave, have you heard of the latest angular version?  We are going to use it or, you know, function as a service are pretty cool.  What do you say?  We will give it a try in this project?  Just says there will be more than happy to work with.  You will approach this.  We.  The last person we look at is surely the *CEO, Chile is a very business oriented person and she always  looks for the financial bottom line*.  If you want to explain her, what are the advantages of the architecture you are working on?  Never mentioned technical buzzwords.  Chile, the kind of person that when his micro services or kissing or even Gever, she immediately  loses interest and stops listening.  *However, if you will tell her this, the architecture of design will ensure the continuity of the business  and will be able to cope with the high load expected during Black Friday sales.  Then you got her*.  She will listen to you and will appreciate the work you are doing.  So to recap, always keep in mind what really matters to the person you are talking to.  Try to be in his shoes, not yours, and then show him how your work contributes to his interests.

=== Section 4: The Architecture Process

==== Introduction

Welcome to the architectural process section in this section, we will discuss the process of the architect's walk in order to make the architecture as useful as possible and to provide the maximum value to the client, the architect should follow. *A well-defined roadmap set at the end will lead to practical and well-thought-of architecture*, which will ensure the system is fast, secure, reliable and easy to maintain. In this section, we will talk about this process. I'll give a brief overview of each step in the process and describe its importance in little sections. We will deep dive into each step and talk about what exactly should be done. So here are the steps in the architecture process. Understand systems, requirements, understanding non-functional requirements, map the components selected technology stack designs the architecture right architecture document support the development team. Let's talk about these steps.

image::architecture-process.png[]

==== Understand the System Requirements

The first thing an architecture should do when beginning a walk on a new system is to understand the system's requirements. OK, well, actually the first thing is to understand the *system's goals*, as we discussed earlier in this course. But an actual architectural process begins with the *requirements*. Remember the requirements, describe what the system should do. The *usually begin with high level tasks*, such as allowing users to view telemetry data and often describe also workflows, logical services and user interface elements. *Those requirements are usually defined by the system. Analyst works directly with the client*. So in most cases, your first walk meeting after the obligatory introductory meeting will be with the system analyst. In this meeting, you will discuss the requirements of the new system and probably set dates for future meetings on the same subject.

==== Understand the Non-Functional Requirements

The next step in the architectural process is to understand the non-functional requirements of the system, not functional requirements of a special kind of requirements that define some technical and service level attributes of the system. For example, the most common non-functional requirements are about concurrent, no refusals, heavy load volumes of data and performance. *As we will see in a later section, the client and the system analyst are usually not aware of the non-functional requirements, and it is the architect's job to help them formulate those requirements*. For us, the architects, the non functional requirements are *much more important than the regular requirements*. I never begin to work on a system before knowing exactly what it's non-functional requirements are because so many architectural elements can be affected by those requirements.

==== Map the Components

The next phase of the architectural process is mapping the various components of the system, the components of the moving parts of the system that *represent the various tasks of the system*, functional as well as non-functional. The component map serves two goals, it *helps you understand the system and its various parts*. It's a *great way to communicate to the client your understanding of the system*, thus making sure you are not missing anything. Note that the component is completely non-technical. You are yet to decide on the platform, the development tool, the database type. This is just a map that displays the various capabilities of the system.

==== Select Technology Stack

This is one of the most important steps in this process, in this step, you are going to decide, *together with the development team*, *what will be the platform* on which the system will be based. Usually, there will be *more than one technology* to be used in most systems. You will have to select *the backend platform, the front end platform in the DataStore platform*. In addition, in some systems such as walls that are based on medical services, architecture, you will often select multiple bakin platforms and perhaps also multiple data stores, as we will see in the relevant section. There are a lot of factors you have to consider when selecting the technology stack, and the selection must be very rational irungu technologies that can lead to failure of the whole system.

==== Design the Architecture

This is the *heart of your work*. You already have the requirements, the non functional requirement, the components in the technology stack. All that's left is to design the architecture that will glue all those together and will result in a system that is first secure, reliable and easy to maintain. We will learn about the qualities of a *well-designed system* such as loose coupling statelets, scaling, caching, messaging and lots more, and see how those qualities are used as the *building blocks of the architecture*. When you are done, you will have a complete architecture in place, but it would be formalized yet. Which brings us to the next step.


==== Write the Architecture Document

This is what you were waiting for. This is a culmination of all the effort you've put into the system and this is your greatest creation. The architecture document describes the whole process you have been through and gives the developers and management a full picture of the system that is going to be built. A good architecture document is relevant for all the levels in the organization, the CEO, the CIO, the project manager and of course, the developers. They will all find great value in it. We will talk a lot about the structure and the content of the document is relevant section and explain how to maximize its value.

==== Support the Team

A lot of architects believe their job is done once the document is delivered. This is a big mistake, huge sort of architectural is a living, breathing creature, and it changes all the time. You have to be there for the developers to help them to make sure they are developing according to the architecture and to be part of the dilemmas that are going to be raised. And they are going to be a lot of dilemmas, arguments and talks in the architectural will be changed and not only once. So you have to support the team if you don't want the documents to become a glorified paperweight. And remember, you are not done until the system is in production. And even then you probably will have a lot to do.

==== Conclusion

So this is the architectural process I use with almost all of my clients, and I recommend you to do the same, be a will that will almost always be some variations on the process. For example, what subject you should be aware of is who else participates in every step of the process. Let's look at the nonfunctional requirements step. Obviously, you, the architect, cannot decide what are the non-functional requirements without talking to the client and the system analyst in the architectural design phase. I was supposed to do it all by yourself or should involve the developers. The answer is, as always, it depends. If the developers are available for taking part in the architectural, then by all means, walk with them is extremely important to let them be part of the process because you will able to benefit first. If there are some scenarios you are not aware of but the developers know about, it would be better to talk about them as early as possible and not when the architecture is done. Second, since the architecture was built together with the development team, you neutralize any future disagreement. But over this way, the developers become ambassadors of as architecture and they will convince the other project members that architecture is a good one and should be used. This will make your job much easier. It will free your time to work on the really important things instead of organizational politics. In the next sections, we will deep dive into each of the steps we have talked about and will understand the ins and outs of the tasks you, the architect, has to execute in order to design a good and practical architecture. Let's go.

=== Section 5: Working with System Requirements

==== Introduction to Requirements

Welcome to the requirements section of this course in this section, we will discuss the basis of all the software systems in the world, the requirements, every softball is based on some kind of requirement, some kind of user needs to accomplish something, and the software helps him to achieve something. The requirement can be, I want to apply filters on my photos or I need to communicate with my friends easily, or even I need to be able to tune my audio recording. Whatever is that user need. These are the requirements. Of course, requirements are never left in such a high level. During the development cycle, they become more detailed, so the developers will have a clear idea of what they need to develop. In this section, we will discuss two kinds of requirements and we will see how they fit in the architecture walk. Let's go.

==== The Two Types of Requirements

We're talking about systems requirements, we usually think along the lines of what the system should do, we expect the requirements to deal with the following questions. *What are the business flaws of the system*? For example, log in storing photos, receiving and crunching telemetry data and more. *What business services should the system have*, for example, local service, data, access service, telemetry receiver, telemetry control. *What does the user interface of the system looks like*, the look and feel, general guidance, responsiveness in the more. These requirements are called *functional requirements*, you can identify the requirements from Miles if they answer the *question what the system should do*, they are functional requirements. Functional requirements are, of course, extremely important in no system should be designed and built without them. I had the pleasure of working on a system without concrete functional requirements, and I swore I would never do that again. However, for the architect, these requirements are important, but not as important as the other kind of requirements. These requirements are known as *non-functional* requirements, and these requirements answer roughly this question what should the system do with non-functional requirements? Describes the various aspect of the systems operation and are not tied to a specific behavior or logic. The most common non-functional requirements are *performance load, data volume, concurrent users and SLA*. For those of you not familiar with all these terms, don't worry, we will cover them later in this Section one functional requirements of the requirements that really interest you as an architect. I once had claimed that asked me to design an architectural system he was planning on field site. The system looked quite simple. Simple rest services that receive data make some calculations, install the results in a database piece of cake, or so I thought. Towards the end of our requirements meetings, I asked the client what would be the maximum size of the data received by the service. He looked at me with an I have no idea. He's made some phone calls, paid a little, came back to the table and said, Well, 600 megabytes boom. No architect in his right mind will expect a service to deal with such huge requests. We had to return to the drawing board and ended up with a completely different architecture. The services have gone and instead we had agents listening to a no secret database and waiting for the data to be stored. And that's just one example of an architecture that gets turned upside down because of *non-functional requirements*. So now that we understand the difference between the two kinds of requirements, let's take a closer look at them.

==== Architects & Functional Requirements

Will we just say that non-functional requirements are the most important requirements and that the architect should not under any circumstances design the system without knowing what the functional requirements are? But it is equally important to be aware of the functional requirements. Many architects feel they only need to skim over the functional requirements and concentrate on the nonfunctional ones. That's a mistake to remember our definition of the architecture. Remember that good architecture must improve the business bottom line. That won't be possible if you are not sure what the system should do. So before diving deep into the functional requirements, this is a not so gentle reminder that the functional requirements are equally important and you have to be well versed in them.

==== Non-Functional Requirements

We have already explained what non-functional requirements are, but let's go over it again just in case. Well, *functional requirements define what the system should do. Non-functional requirements describe what the system should deal with*. Systems can deal with many challenges during the operation. They can experience a large number of concurrent users. They can experience several Krush. They can suffer extremely high load of requests and so on. Nonfactual requirements basically describe what is expected environment for the *system with emphasis on edge cases*. If you will, take a look at the Wikipedia page for all functional requirements, you will see a long list of those requirements. In real life, however, there are five non-functional requirements that we will usually deal with. *Those five are performance load, data volume, concurrent users and SLA let's* discuss each of them performance. Well, that sounds like a simple requirement, right? What is the required performance for this system first? It easy. Well, not so fast. See what I did here when talking about performance? There are two things we should keep in mind. *One, always talk in numbers*. And *two, latency and throughput*. Let's talk about the first one. When the client asks for a fast system, your next question should be what is first fast can mean a lot of things. In a lot of systems I worked on, systems were first meant 30 milliseconds and on systems that were first minute, five seconds. The problem is that your client probably wasn't thinking on the exact number and you will have to help him with that. *The rule of thumb is* that when there is an end user at the end of the flow, we usually need the *task to be complete in less than a second when* walking in a *B2B environment* that the business to business, we are usually looking at faster systems that can measure even *one hundred milliseconds per task*. The reason for that is that we human beings are less sensitive to subsequent delays. And for us, a data that is displayed in one second or seven hundred milliseconds looks almost the same. Wilfork with software running on a machine with CPU cycles of few milliseconds. This would be a very long time. But again, the most important thing is to walk out this number together with a client or system analyst.

The *second* concept is about latency and throughput those towards defines the way we look at performance and give us two points of view on it. Let's begin with latency. *Latency* answers the question, how much time does it take to perform a single task in the application? For example, how much time will it take for the API to set the user data in the database? Or how much time will it take to read a single file from the file system? You can see that latency deals with the time it takes to perform a single task *throughput*.

On the other hand, until a completely different question, *how many tasks can be performed in a given time unit*? For example, how many users can be saved in the database in a minute? Or how many files can be read in a second? Now, let's look at some numbers so we can understand better the difference between latency and throughput. Let's say the latency of saving user data is one second. This is quite slow, but let's stay with it for the sake of the discussion. Now, what would be the throughput? Can we know how many users can be saved in one minute? The answer is a resounding no. If the application is well designed, deployed on a strong Hellewell and knows its way around threads, it might have its throughput of one thousand users in one minute. On the other hand, if the code is buggy and there are a lot of memory leaks and no concurrency at all, we want to be able to reach a throughput of 60, which is a latency multiplied by 60 the number of seconds in a minute. So this is the difference between latency and throughput and we are discussing performance. Both of them must be mentioned and.

Now let's talk about load the load on functional equipment defines what it is, the load or quantity of the application you have to withstand without crashing. The exact definition of low depends on the exact type of the application. For example, for a Web *API based application*, the load will usually be defined as *how many concurrent* requests are going to be received by the system without crushing. Note that this requirement *looks similar to throughput*, which defines how many requests can be handled in a specific time unit. The difference between the two is that way. *Throughput defines the time unit*. *The load defines the availability of the system*, meaning the system should be able to handle the load without crushing down. For example, the performance requirement can dictate throughput of one hundred requests per second, but the system should be able to handle 500 concurrent request without crushing, even if those requests will take more than a second to complete. This definition is important, since the worst thing that can happen to a system is to crash under heavy load. Users can tolerate a slowdown when there is a load, but they won't like it if the system will crash and burn. So the best practice here is to always look at peak numbers. For example, for an e-commerce website to regularly load might be up to two hundred concurrent requests. But on Black Friday we are looking at more than 2000 concurrent requests. In that case, we should plan for the extreme case because this is when it's more important for our system to be alive and functioning.


Next is *data volume*, this requirement defines how much data in gigabytes or terabytes or system will accumulate over time. This requirement is important for a few reasons. *It will dictate what kind of database we are going to use, since not all databases can handle large quantities of data equally*, it will also *determine what type of queries we are going to write because a query* in a table of 100000 rolls will be completely different from a query in a table of 100 million rolls. And of course it will help us plan ahead. The storage we need to allocate the data volume usually has two aspects. One, *how much data is required on day one*? *And two, what is the forecasted data growth*? For example, the system might need 500 megabytes on its first day and is expected to grow by two terabytes annually. Of course, the growth period can be different and can be weekly, monthly, quarterly and so on.

Next is *concurrent users*. This requirement defines how many users will be *using the system simultaneously*. This requirement is quite similar to the load requirement, which also defines how many requests should be handled by the system simultaneously. But with *one big difference*. The concurrent users requirement describes *how many users will be using the system*, *not how many users will be performing requests*. This distinction is important when a user is using a system. There are a lot of dead times when no action is actually taken. For example, a user is asking the system to display all the data. The system executes an API that goes to the database and retrieves the data. This is an actual action. Now the user is looking at the data. During this time, the system is doing nothing. The API is not working. The database just sits there and the network is silent. So as you can guess, systems that can hold 500 concurrent requests will be able to withstand a much higher number of concurrent users. *The rule of thumb* is that concurrent users are 10 times the number of concurrent requests. So if the system should work with 500 concurrent requests, it can support 5000 concurrent users. But this number actually depends on the type of system. And the usage pattern

*SLA*. The last functional requirement will discuss is SLA SLA, which stand for service level agreement, *describes what is required uptime for the system in percentage*. This term is widely used by almost all public cloud providers. One of the biggest competitions between them is on the SLA. For example, as customers, Deby takes pride with its ninety nine point *ninety nine percent SLA*. This is translated to *less than an hour of downtime in a year*. Take a look at the numbers. The SLA has great influence on the design of the system. For example, a system that cannot be brought down must have a sophisticated uplink mechanism that won't require tuning of the system while it's operating. This is possible, of course, but it has to be designed this way. One important thing to note about this is client expectations. If you will ask the client what is required for the system, he will usually give you an answer along the lines of one hundred percent of the famous five nines, which is ninety nine point ninety nine percent. *When this happens, I usually tell him, no problem for this, we will need to build at least three data centers in different continents with independent and dual power stations in automatic fill over between them. What do you say?* This generally brings him down to earth and we discuss more realistic SLA goals. So these were the most common, non-functional requirements you will need to have for the system. And again, never start working on the architecture before you have set those requirements.

==== Who Defines Non-Functional Requirements?

One of the biggest problems with the no functional requirements is that it's not clear who should define them. Usually we expect the client together with a system analyst, to define the functional requirements. After all, they know what the system should do more than anyone else. But functional requirements are a different story. *Most of the time, the client has no idea about what functional requirements and what the consequences of those requirements are*. In my experience, when asked what is the SLA for the system, assuming he knows what an SLA is, the client will usually say always when asked What is the required response time for the API? The answer will be someone 10 milliseconds. So we the architects have 2 roles in non-functional requirements discussion. The first is to frame the boundaries, we must explain the client that 100 percent uptime is not realistic and probably not really needed. We must explain to him that his current network will not enable completing an API call in less than one hundred milliseconds. And after we have done all this, we can talk about possible values in this discussion must be backed by real numbers. For example, when talking about concurrent users, try to calculate the real number of concurrent users. Don't pull numbers out of a hat. Also, try to set realistic goals for the performance requirement. Remember, if the system is going to be used by end users, you don't need to fight for every millisecond. The users would notice that.

=== Section 6: Types of Applications

Welcome to the application types section. in this section, we will discuss the various application types an architect will work with one of the first things an architect should do when working on a system to determine what kind of applications the system is going to be. *This decision is usually made after working on the requirements. Is a functional or nonfunctional*. In this phase, you have already learned what can be learned about the functionality of the system and the environment it will be operating in. And you can make an educational decision about the type of applications that best fit these requirements. This is an important decision since each type has its own pros and cons. Moreover, once a decision is made, it's usually not easy to switch to other types. The most common application types are Web apps, Web API, mobile console service and desktop. Let's go and discuss each one of them.


==== Web Apps

Web is probably the most common application type nowadays. Second, maybe only to Web API, Web ups, also known as websites, are basically the way the Internet worked since its inception with Web apps. There's a Web server, usually more than one, and a Web browser, though, to communicate with each other via HTP protocol. Although other protocols can also be used, the browser sends and HTP request for the server asking for a resource. The resource in this case is an e-mail page which gets returned to the proposal, which in turn renders it for the end user. Almost always the e-mail page. We use JavaScript code for implementing logic in the browser and files for the visual design of the page

*web are best for systems* that require *user interface* for end user *user initiated actions*, meaning the user is the one making the request to do something such as viewing ordinator, sitting username and so on *large scale with a large number of users* and a lot of data *short focused action as opposed to long running processes*. For example, Web apps are not a good fit for a process that should crunch billions of numbers and produce business intelligence. For this, there are other kinds of applications. As we discussed earlier, we spoke inadequate response model, which is perhaps the most important aspect of them. As a rule of thumb, if the system you are walking on can be described as a request response application, then you are probably looking at a web.

==== Web API

Web API is quite similar to Web App with two *important differences*. One, it does not serve of HTML pages, but data, usually in the form of some structure to its clients, are not Web browsers. But other applications, including JavaScript code that runs inside Web browser.

Web API has become extremely popular in the last few years, and almost every Web expose also will be API. In addition to the more traditional Web. Web API, as its name implies, exposes an API application programming interface which allows other programs to access it and execute various actions. There are various types of web implementation, but the most popular one by a large margin is definitely the REST. API REST is a huge topic with a lot of philosophy in the thinking. But for this course, it's suffice to say that risk allows us to access entities with the combination of your URL parameters and http verb. For example, the following you will be executed by the API as get me user number 17. This all means delete total number 156, as you can see, the main advantage of rest is that it does not require more than a standard. We are able to execute API and it does not require cumbersome protocols on top of the HTTP protocol, as was with the protocol. For those of you who are familiar with it, *Web APIs are used for data retrieval and receiving it should not be used for returning visual markup such as HTML*. For this reason, almost any kind of application can be a client of Web API, any code that can access Riced API. And I believe that almost every language supports that capability can access the API and use it. This is the reason that Web sites are used by Web apps, rich client apps and of course, Azel Systems. *Web applications are built* for systems that require data retrieval and Store, though not huge amounts of data. In each action, Client initiated actions, meaning the caller is the one making the request to do something such as getting all the data saving username and so on large scale with a large number of users and a lot of data and short focused action as opposed to long running processes with API. And the Web apps are built on the same concept and usually shares the same underpinnings. So as with Web apps where Beppo also works best in the *request response model* and should be used for this kind of systems, long running processes should be avoided when using Web API.
this kind of systems, long running processes should be avoided when using Web API.

==== Mobile

Well, I guess you can guess what this tape is all about, mobile apps, as their name suggests, are apps that run on mobile phones, specifically smartphones, probably Android powered or iPhones. Modern mobile apps connect with the webpages all the time for multiple purposes, logging, loading, next level, storing, user generated content and much more. Actually, there are not a lot of mobile apps, perhaps only games that can function properly without Internet connectivity. Mobile apps will be used mainly for apps that require user interaction, for example, games or social apps. Front end for Web API application for displaying various types of content, for example, news and apps that are location sensitive and will benefit from the phone's GPS.


Console
Service
Desktop


=== Section 8: Meet the *-ilities

* Scalability  Adding computing resources without any interruptions (Horizonal Scaling)
* Manageability  Know whats going on and take actions accordingly (Monitoring etc.)
* Modularity  A system that is built from building blocks, that can be changed or replaced without affecting the whole system (replacing monoliths with micro services)
* Extensibility  A system that its functionality can be extended without modifying its existing code (API returning XML | JSON. It has to return CSV. Extend the code. Use dependency Injection)
* Testability  Independent modules and methods + single responsibility model for methods

=== Section 9: Components Architecture

* Layered Architecture

* SOLID
Liskov: If S is a subtype of T, then object of type T may be replaed with objects of type S, without altering any of the desirec properties of the program.



