= Allen Holub UML
:toc: left
:toclevels: 5
:sectnums:
:sectnumlevels: 5

== Picturing Architecture: UML (The Good Bits) and More by Allen Holub

=== Introduction: Designing in an Agile World

==== Introduction

Hi, my name is Allen Holub and this class is called Picturing Architecture. Now the reason I put it that way is what this class really is about is communication. Unless you're working in a cave on a mountain top, you can't really program effectively unless you can talk to other people about what you're doing. And when you're doing that, talking that is, looking at the code just doesn't cut it. The code is just too complex, and the overall structure just isn't clear enough. So my goal in this class is to provide you with an effective visual tool kit that you can use to talk about the structure and the behavior of your code, about its architecture in other words. I'll talk about how to do that using pictures mostly, but I'll also talk about using index cards and other aids to visualization. UML is also going to be a big part of this discussion, but we'll look at a modern take on UML tailored to the way that we work now days. In fact, one of the biggest changes between now and when UML was conceived is that now days we do most of our design work standing at a whiteboard talking to other people, not inside a computerized design tool. So instead of talking about a version of UML that's optimized for a machine to do the drawing, we'll talk about one that's better when you're standing at a white board. Over the course of this class, I'll take you through the process of designing a small blogging system starting with stories and ending up with something very close to the code. That way, you can see how everything ties together at every stage of the design process. So, let's get started.

==== Designing in an Agile World

Software, once you strip away all the layers of abstraction, is really just a big pile of numbers. In fact, even those numbers are abstractions. They're abstractions for a bunch of electrons moving around on a sheet of dirty sand and aluminum. We paltry human beings are just incapable of thinking about software in those terms however. Reality is just too complicated, we have to think in terms of some metaphor, that is, in terms of pictures. We all have mental pictures of what we're building as we build it of course. When it comes to a tree or a linked list or a hash table, we think about a picture in our head, not about the underlying numbers. And of course if we're all using the same pictures, we can use those pictures to communicate with each other. The notion of drawing a picture to represent code comes, I think, from the architecture of buildings. It's not an accident that we call what we do software architecture. When you're making a building you start with a detailed plan. In other words, you design the entire structure before you start building. You do that because experimentation, when it comes to buildings at least, is just way too expensive. You can't just build the building and then start tearing out and replacing the parts that you don't like, you've got to get it right the first time. Thinking that building software is like building buildings though, has created a lot of problems. Software isn't made out of concrete and rebar. For example, the cost of changing a part of the code that you don't like is trivial and working in a way that just pretends that it's not is just stupid. It took us a long way to come to that realization however. Back in the early 90's, we all thought that software should be created just like a building. You'd start with a detailed picture, a big upfront design, usually created from an enormous requirements document that you put together before you designed anything. It might take months to put together the requirements document and then the design. You'd then try to build exactly what you had drawn. *In fact, the thinking at the time was the architect was doing the real thinking here and that the code could just be written by monkeys*. Back when we were working this way there were several warring notations that people used to draw those pictures. *But the two big ones were Grady Booch's Booch Notation and Jim Rumbaugh's Object Modeling Technique or OMT. Eventually Booch and Rumbaugh got together along with Ivar Jacobson and merged their systems together into the so-called Unified Modeling Language, or UML*. UML had a few problems from day one though. The first issue is that it wasn't ever really unified. Booch Notation and OMT often did the same thing in different ways, and UML glossed over that by putting both ways of doing things into the standard rather than picking one. As a consequence, there was a lot of room for confusion. *Also, UML was so detailed that it was effectively a programming language*, remember our monkeys. A**s a consequence, you were really writing the program twice. Once in UML and once again in whatever your choice of programming languages was**. Doing anything twice is usually a waste of time and if it isn't, it's because when we do the rewrite we can leverage all of the things that we learned when we wrote it wrong the first time. Applying this to doing it in UML first, the system that we built leveraged everything that we learned while doing the UML, which is to say it hardly ever looked like the original design. There was some question then about whether we should be doing that kind of design work at all. Now moving forward to the present, now days we think in terms of agility. We're working in an agile world where we don't do a big up-front design. And I have to say I consider myself a pretty agile kind of guy, at least when it comes to software. Once you drill down into Agile, one of the things that you notice is that it's all about communication. Two or more people conversing in front of a whiteboard. But what exactly are those conversations? Well, in a waterfall world, we'd have most of those conversations at the beginning of the project when we were putting together that giant requirements document. In the Agile world, we'd spread those same conversations over the entire development process. It's important to notice though that it's the same conversations, they're just spread out. It's a mistake then to think that we're not doing any design inside Agile. *What we are doing is incremental design. In other words, we'll do the design bit-by-bit over the course of the whole project. You build the code incrementally too, and you learn things as you do that. Now if we had a big upfront design, the things that we learn might render that design useless. But in the Agile world we don't have that*. Instead, we defer making decisions until we have enough information to actually make the right decision. In other words, we delay our decisions until the last responsible moment. That way, when it comes time to make the decision, we can leverage everything that we've learned up to that point. We still have to be thinking about structure though, and coherence, and to do that, we have to be thinking about the larger system. So that brings up the notion of useful ambiguity. We want to design in a way that is ambiguous enough that as we learn things, we can incorporate what we're doing into the design without impacting the design in a serious way. We want the design to help us think about structure, but we don't want it to force us to commit to a specific implementation. So when we draw a picture of a design we want it to be a little bit fuzzy. We don't want it to be a programming language, we want it to be a rough sketch that we can fill in as we work. So, starting with the next module I will show you how to do that.

=== Organizing Stories

==== Stories and Story Cards

So when it comes to picturing architecture, let's start at the beginning, the beginning of the design process that is. In this module I'll talk about stories and ways that you can organize the stories and graphically represent them for planning purposes. First though, I've got to talk a little bit about exactly what a story is. Because without that background, the notation I give you later on won't make much sense, and a lot of people don't really understand what a story is. That said, the notion of a story is central to Agile development, so we better get things right. So the term story is not some made up perversion of an English word as we often find in computer science. How many trees for example have the roots on top waving around in the air? What a story is, first and foremost, is exactly what it says it is in a dictionary, a narrative. More precisely, it's a narrative that takes a user through some process that produces a result that's valuable to that user in the real world. In other words, a story describes a process. It does not describe a thing. It's a verb, it's not a noun. So a story is not a fancy way to say feature request. Adding a button is not a story. There's no user level narrative there, and the typical user could care less how many buttons our program has. What our users do care about is that they're accomplishing something when they use the program and that's what the story captures, what they're accomplishing. Stories don't stand alone in isolation though, they exist in some context and we context that context a system metaphor. Think of the metaphor as the environment in which the story plays out, the stage set if you will. So on our blogging system I've picked a magazine as a particularly useful metaphor. The metaphor provides us with a bunch of abstractions that we can model in the code, and we understand those abstractions intuitively, or we will if it's a good metaphor. A magazine has publishers and readers and writers and articles and a host of other things that we thoroughly understand. If the structure of our code models that metaphor, then the code structure will also be intuitive and easy to understand. The pieces will fit together in a coherent way. So the metaphor is really a picture of our system architecture, albeit a mental one. And that's the first picture of value that we're talking about, one that's inside your head and there is no UML in sight. Now having decided on a metaphor, our next task is to concoct a few stories. The best way to represent a story is physically, on an index card. Now that card doesn't have the entire story in all of its gory details on it, it's just a sentence or two. Think of it as a place holder for a detailed conversation that we'll have with our users just before we start coding. Here's an example. Now this particular story is represented in a formulaic way, I'll talk about that in a second, and there's way more work here than we could do in a two-week release cycle, which is common in agile shops. So this particular story is called an epic, because it's so big. In other words, it's a placeholder not for one conversation, but for a whole set of conversations, for a whole set of stories. There's an important thing to notice here though, even at the epic level. Reading our sentence, are writers really just interested in expressing their opinions? I'd say no, they want their opinions to be heard, to be influential. So let's change the story to reflect that goal. Now that one change might have a dramatic impact on our code. If we're thinking about being influential, we're also thinking about how do we disseminate the thing that we just wrote? In other words the program is going to have to have features now, that it didn't have before, things that have to do with dissemination, sending out an email, for example, when we add a new blog, or automatically tweeting about it. So crafting these sentences carefully is really important and keeping the real goals of the user in mind as we craft these sentences is, if anything, more important. Now going back to that formulaic piece, stories are often represented using Mike Cohn's template. The basic form is as an x, I need y, to do z. Filling in the blanks that x is a role that the user is taking on. In other words, it's as a user in the role of x. Don't confuse those roles with the actual people. Sometimes for example I'll log on to a system in the role of author in order to write a blog, at other times I'll log onto the same system in the role of administrator to do some kind of administrative task. The fact that it's the same person, me, in both cases doesn't actually matter. What matters at both the code and the design level is the role that the person is taking on when they log on. The next chunk is the I need to do part. What this is, is the set of activities that someone in the given role will perform in order to achieve some kind of valuable result. In other words, this section describes a set of domain level activities, it does not describe a user using a computer program. We're going to keep everything inside our system metaphor, so all of the activities that are described here are things that should go on in the process of publishing a magazine. You don't put anything about how to use a computer program onto the story card. What you will see there is what the user would be doing if the program didn't exist. The third clause in the template shows us the outcome that we are trying to achieve. Again, this has to be something that is valuable to our users. Logging in for example is not a story, because there is no valuable outcome there. You don't log in for the sake of logging in. Now, in an Agile shop, our unit of work is the entire story. In other words, we're going to work one story at a time, building everything from the UI all the way down to the database. If the stories are small enough, we'll be able to all of that in a week or two and at that point we'll have something that we can actually release. We'll have a piece of working code. So one of the advantages of working in an Agile way is that the program always works. Now it' doesn't do much at first, but it actually does fully function. As we continue to build to the program, we'll implement additional stories, from front to back, and the program will gradually become more and more useful over time. The main point here though is that we could stop work at any point and we will have a fully functional program. We'll never be in that situation where we work for six months on some corner of the program, and the program still doesn't work at that point. Now there's one final nuance. When I do stories, I personally like to reorder the canonical form to put the outcome first, mostly because it keeps me focused on what I'm trying to accomplish, which is after all the most important part of the story.

==== Story Maps

Now once we have a handful of stories, we need some graphical way of representing a whole set of them so we can figure out what to work on first. *Our goal here is that we always want to work on the most important thing, the thing that has the most value for our users*. The best tool that I know for doing that is not a picture, it's something called a story map, which is a board or a wall with a bunch of cards or Post-it notes on it. Story maps were developed by Jeff Patton, and he describes them in his book User Story Mapping. And I strongly recommend that you read it, it's a great book. I'm going to look at the structure of a map momentarily, but Jeff's book has all of the details that I'm not going to have time to talk about in this class. Now a story map is a grid on which we put all of our story cards. Usually when I make a map, I have a couple of piles that are not really part of the map, the pile of stories to the left are my percolating stories. In other words, these are things that I think we're going to work on at some point, but I don't really want to think about them now, I might not have enough information about them. In other words, it's a slush pile for things that I don't want to forget about. I like to keep these visible so that I can think about them occasionally. In other words, I like to put story maps in some big public place that I walk by all the time, and every so often when I walk by the map, my eye will be caught by one of the cards in the percolating pile and I'll give it some more thought, maybe move it onto the map proper. The pile of stories on the right aren't part of the map either, that's just the pile of things that I finished, and it just makes me feel good to see that I finished something. If you are a management sort, you'd be really interested in the rate at which stories move from the map into the finished pile. So actually having a finished pile there actually gives us some useful information from a management point of view. Now going to the map itself, the column headings are broad categories of activities within our milieu, within our metaphor. Typically, you'll have to implement at least something in every one of these activities in order to have a fully viable system. And if the activity is a big activity you can break it down into sub-activities as I've done here. The next step then is to take the story cards and put them on the map in the right column. Now of course, stories are not necessarily going to cleanly fit into one column or another, so we'll just put it in the one that seems to make the most sense. Stories are organized by priority, by value. So the closer you are to the top, the more valuable the story is. Once we have all the cards up on the map, the top row is the minimum set of things you need to do to have a fully useful system. You can think of it as the proof of concept system. In other words, we'll implement the story by going left to right across each row. So we'll go left to right and top to bottom. By doing that, we're always close to having a fully working system. We're always doing the most valuable thing first, and we're always implementing everything that is at the same value level together to form a release. And we're never more than a few stories away from a release. Or to put it another way, at any moment, we are guaranteed to have built the most valuable program that we could have built in the time available. So there will be none of this work for six months and have nothing to show for it stuff. We can always deliver a working system. Moving on, you're probably not going to want to release to the larger user community after you've done every row. You will be releasing to somebody but just not to everybody. So one of the things we have to decide is when we're going to do formal releases, and the way that we indicate a formal release on the story map is just by putting a horizontal line across the map at a reasonable place. Real maps, of course, are much bigger than the one I've shown you here, but they're not a lot bigger. At any given moment, a large map might have thirty stories on it. That's a pretty good sized map though. The reason you don't want to go above thirty or so is that those stories are going to be implemented so far in the future, that the odds of getting them right now are just about 0. So if you think there's more to do than the thirty things that are in front of you put it over in the percolating pile. Finally, note that this map is a dynamic thing, which is one of the reasons it's better to do it with physical index cards or with Post-its than with a drawing. New stories will appear, usually because the user is working with the code and realizes they forgot something. Existing ones will disappear because we realize that they weren't as valuable as we thought they were, priorities change, cards move around. Now one of the problems when you put together a story map is figuring out the best way to order the cards, in other words, what are the actual priorities?

==== Story (Use-case) Diagrams

So there actually is a real drawing that's pretty helpful in doing that. I call this a story diagram. UML called them use case diagrams. It's the same picture, use cases and stories are very similar, though not identical concepts, but since I'm an Agile guy, I'm thinking in terms of stories here not in terms of use cases so I call it a story diagram. You represent the stories in the diagram with a circled name, and you can use a stick figure to represent the roles that are involved in that story. UML calls these roles actors, but role is actually a more correct way to look at it, so let's call them roles. Here, somebody in the moderator role creates a magazine. In story card form, I'd be saying something like, as a moderator I need to create a magazine to do something or other. Now let's add a second story. As an author I need to create an article, or maybe I should have said I need to write an article. One way or another, we have a second story. Now there's a dependency relationship between these two stories. You can't create an article unless there's a magazine to put it in. That doesn't necessarily mean that we have to create the magazine before we create the story, but if we don't create the magazine, we'll have to go about creating the story differently. There'll have to be stubbed-out objects for example that would be real objects if we had done things the other way around. I'll represent that dependency with a line and an arrow pointing towards the thing that has to be done first, think of this as a depends-on relationship. If A depends on B, the arrow is pointing at B. Now I'll add another story. As a reader, I'd like to comment on an article, and I'll set up the dependency. The comment is dependent on creating the story because it makes no sense at all to comment on a nonexistent story. Now my thinking when I came up with this design was that the comment was going to be added to the comment thread as soon as it was written, but it would be invisible. If the comment was approved by some moderator then I would make it visible, if it was not approved then I would remove it from the thread. Here I've specified two possible actors, in other words, either an author or a moderator can approve a comment. Now let's add another story. This one is really a variation on the last one. It's a kind of approval, but I want to be able to approve by email. In other words, I'm imagining that the system will send an email out to the moderator, and if the moderator responds to that email, then the story's approved. Now, you can label the dependency lines to make what's going on a little bit clearer here. You do that with something that UML calls a stereotype, a short comment string that's surrounded by guillemets, those little angle bracket-like punctuation marks. Note, by the way, that these are actual punctuation marks. They're not two less-than and two greater-than symbols. The requires stereotype here is really just the default meaning for a line so adding it explicitly is really just noise. The extends stereotype, however, tells us something interesting. Here I'm saying that the email story is an extension of the more basic approval story. Or put it another way, we probably would have done most of the work of the email story when we did the approval story, so the email story should be relatively short. Now, once we've got all our stories up here, we'll have a bunch of circles and a bunch of dependency relationships. Those stories that have the most incoming arrows are good candidates for things that happen first. In other words, a lot of things depend on those stories, so if we do them first it'll make it easier to do other things down the line. Also note that an epic is really a sort of story, it's just a really big one, and we can put it on the picture as well. I've done that here, but I've used that little upside-down trident symbol, which is part of UML, to indicate that this is an epic. So those are the two graphical ways that I represent stories as I'm working. In the next module, I'll drill down a little further and show you how I figure out what we have to actually do in order to implement the story. I'll do that using another type of UML diagram, an activity diagram.

=== Diagramming Activities

==== Activity Diagrams

Now let's move on to the activity diagram. The point of an activity diagram is to show us all of the activities, all of the things that somebody has to do, in order to work our way through the story. There is a lot more detail here than you'd have on a story card, and the way we get that detail of course is by talking to our users. So the activity diagram is particularly helpful when you're sitting down with a bunch of users trying to figure out exactly what steps they have to go through in order to achieve their valuable result. That's one of the main values of this diagram in fact, there's no coding involved so it doesn't matter whether or not your users can read code. Now the set of steps that you have to go through could be very simple, could just be a linear list. And if that's the case, there's absolutely no reason to make a picture like this, just make a bullet list and code it. Most stories are more complicated than that though, which is why a diagram is handy. I should say by the way that that's a general rule about all of these diagrams. If you can represent something better in code than you can in a picture, then do it in code, don't do the picture. We're not doing big upfront design work here. Our goal is to write the code, and if we can go straight to the code, well all the better. Now going back to our picture, an activity diagram is going to sketch out all of the steps for a particular story, and in fact often an activity diagram will sketch out the steps for several stories combined. In fact, I'm going to take that approach here and I'm going to create a single activity diagram that shows all of the activities associated with both of the comment approval stories that we looked at in the last module. Now all sets of activities have to start somewhere, and we indicate that in the diagram with a big black dot. That's our start symbol. Then I'll add the first activity, somebody needs to create a comment. And then the next one, somebody needs to add the comment to the dashboard. Now note that all I'm capturing here are the activities themselves, I said someone has to. I really don't care who's doing the activity when I'm putting this diagram together, that's a decision I'll make later on as I start moving closer to the implementation. *Here what I care about in other words, is what is happening*, not who's doing it. Now let's keep going. The next thing I need to do is add the comment to the comment thread. The issue here is that I really don't care whether I do that before or after or even at the same time as I add the comment to the dashboard. UML lets us represent that situation with something called a fork. The fork here is the heavy black line on the top, and a join which is the big black line on the bottom. The basic idea is that operations in-between the fork and the join can be done in any order, or they could be done concurrently. However, they all have to complete before you can move past the join, before you can move past the big black line on the bottom. Think of that join as a kind of and operation. We have to do A, B, and C before we can proceed. Now my strategy of posting an invisible comment is certainly not obvious here. So just to make things just a little bit clearer, I'm going to add a UML comment. Now note carefully how I'm drawing this thing. Let me rewind and draw it again for you. I'm drawing that turned down corner first before I draw the rest of the box. If you don't do that, I guarantee what you'll do is draw a square and then realize that you've forgotten to do the corner and then have to erase a corner of the square. If you draw the corner first, you won't have to be doing quite so much erasing. Now our next activity is to send an email out to the approver. I'm going to do that regardless of whether I'm going to accept an approval by email. In other words, one way or another I've got to notify the approver that there's some work to do. Since this sort of activity, sending an email, affects the outside world, I'll use a special kind of box, that sideways house thing, instead of a circle to indicate that. So you can think of this as an activity that's pointing out of the program. Now we have some options. There's more than one way for the comment to be approved and we want to show all of those ways here on our picture. The first option is to make the decision on the dashboard. That's a normal activity so I put a circle around it. The second possibility is that we can receive a reply from our notification email which we'll take as an approval. Now this is an activity that's triggered by something outside of the program, something outside of our control, so we'll indicate that with a visual inverse of our sideways house. This is a box with a bite taken out of it. So again when you see that, what it means is that this activity was triggered by something outside. The third option is that nothing's happened, nobody's logged on to the dashboard, nobody sent us an email, so the decision I'm making here is that we're going to reject the comment in that case, at least that's the safest approach. UML indicates that a certain amount of time has elapsed with a little hourglass symbol. Now in order to indicate that we have three possibilities, I have a little diamond that everything splits off of. That diamond is called a split in UML. In other words, the flow of control has split into three alternative paths. We will only do one of the three things, but we don't know which one here. Think of this diamond, in other words, as a kind of or symbol. Now moving on, if our user opts for the dashboard approach, we have another split. If he or she rejects the comment, we'll go in one direction, if they accept the comment, we'll go in the other. The bracketed words that I've put on the lines here are called guards. You traverse a guarded path only if the statement inside the guard is true. So let's take the approval path. There are two ways that we could have gotten here and we'll show that by adding another diamond into which these two ways merge. So the second diamond is called a merge. The first one was a split, this one is a merge. A split has one incoming arrow and many outgoing arrows. A merge has many incoming arrows and one outgoing arrow. Now once we've merged these two activity flows, the next step is to display the comment. In other words, no matter how we approve the comment, we always want to display it. Now I'll add a second merge on the reject side, and this one is going to lead to the delete comment activity. Okay, so there are no more activities in the current flow, and I'll indicate that with a target state, which is a big black dot with a circle around it. There's one final nuance that's worth looking at. Occasionally an activity generates some sort of work product that's worth showing on the diagram, so in this case, the create comment activity outputs a work product, a comment. You can indicate that with a little labeled square on the outgoing edge. I'll finish up with just a practical note. The split and merge diamonds were put into UML mostly because it's easy for a computer program to create these things. When we're working intuitively, we're not really going to be thinking in terms of formal splits and merges and diamonds, instead we're just going to be thinking of multiple arrows going in and out of the activities. So on a white board, more often than not, I'd just skip the diamonds altogether and just draw the arrows, as I'm doing here. So now we've moved our story a little bit more towards code. We've sat down with our users, we've had a long conversation and figured out what activities we have to do in order to get from here to there, to get to the useful outcome, and we've sketched them out. The next step then is to think about what code we're going to have to write in order to perform those activities, and I will show you that in the next module.

=== Visualizing Message Flow

==== Collaboration Diagrams

So now that we know what we have to do, we have to figure out how to do that. We'll do that by using one of two diagrams, which fall under the rubric of interaction diagrams. *These kinds of diagrams show us how objects interact at runtime in order to get some work done*. There are two variants on the interaction diagram. There's a collaboration diagram, which maps pretty closely to the original Booch notation, and there is a sequence diagram, which is more of an OMT style diagram. The collaboration diagram is actually much more useful on a whiteboard, so let's take a look at that one first. A collaboration diagram is going to show the objects that exist at runtime and the messages that they send back and forth to each other in order to get some work done. Typically you'll look at your activity diagram in order to figure out how to build the collaboration diagram. In other words, you'll pick the first activity and then you'll figure out what objects and messages you need in order to make that work. And then you pick the next activity and figure out how that works and so on and so forth. So you can think of an activity diagram as a kind of outline that we're going to flush out at the collaboration diagram level. Now our first order of business is to figure out what objects we're going to be using here. Keep firmly in mind, by the way, that what we're thinking about at this level are objects. We're not thinking about classes yet. We'll look at how to extract classes from this diagram in the next module. Here I've got an object called administrator and it's sending a message to an object called library. Now library is the object's name, not the class name, and that's the case with all of the labels that appear in this diagram. I can put the class name on the diagram if I want to. So here the :Magazine is saying that the library object is an instance of the Magazine class. More often than not, you don't have to do that, but sometimes you don't want to put a lot of thought into object names yet, so in that case you can just put a colon in front of a class name instead of the object name. Now I'll add a message. This one is called display pending comment, and the direction of the call is indicated with an arrow. The 1 says that this is the first message in the sequence. Now that arrow is something of a complication. Arrowheads are meaningful in UML, but the meaning has changed with different versions of the standard as it's evolved. More to the point, the standards committee was dominated by companies that were making software that drew UML diagrams. So the choices often went in the direction of what would be easier for software to draw rather than what would be easier for people to draw. Now days I hardly ever draw a UML diagram in software though, I'm almost always drawing on a whiteboard, so some of the decisions that the UML committee made seem very wrong to me. Now this particular arrowhead is a case in point. Here I've used a stick arrowhead, two lines, because it's way easier to draw than the officially correct version. In other words in official UML I should have drawn this arrowhead as a solid triangle like I'm doing here. That's really annoying to draw on a whiteboard though, so I hardly ever do it. So I consistently use a stick arrowhead to indicate *what's called a synchronous message*. That is a message whose handler doesn't return until it's done doing whatever it's doing, in other words, a normal function call. But again, if this was formal UML I'd be using a triangular solid arrowhead here. Now moving on, the next thing I want to do is send a get pending comments message to each of the posts. You could draw that with some kind of loop notation, and in fact the sequence diagram has this elaborate system for drawing loops that I never use because it's really just clutter. Remember though that I'm not trying to write a computer program here. I don't need to specify a loop. What I do want to show though is what the result of the loop is, in other words, what the loop would be doing is sending a message to everything in a collection of some sort. So here I can indicate that just be using the word every or each inside the object name. The star next to the arrow also indicates that the message is being sent multiple times. So that's enough, we can figure out the rest of it when we write the code. Now this particular message handler is going return something, it's going to return the set of pending comments. I've indicated that with the so-called tadpole, the little circle with an arrow shooting out of it. The tadpole is labeled with the name of the returned object, not a class name, but again the object name. Moving on. The next thing I want to do is ask the pending comment to get approval from the user. My implicit assumption here is that the magazine creates some kind of UI for that purpose. I've left the implementation details up to the coder, though I suppose it probably wouldn't have hurt to put a comment in. It's not an accident, by the way, that I'm using the same pending comment name for this object that I used on the return tadpole in the previous step. By doing that I'm saying that I'm sending this message to the object that was returned from the previous step. If the names didn't match then they would be different objects entirely. Now I go get a cup of coffee and I come back and I look at my diagram and I see that I've left something out. Back when I was thinking about getting the pending comments, at some point I realize I needed to ask the individual comments whether or not they were pending, and I didn't do that. So I'll add the message now. I'll indicate its place in the flow by using a decimal point. That way I don't have to mess with renumbering all of the existing messages. Now this is another deviation from formal UML. Formal UML does use decimal points, but it uses it to indicate a kind of nesting. For example, if you send the message a, and a itself sends three messages, b, c, and d, the first of these would be labeled with number 1, and the others would be labeled 1. 1, 1. 2, and 1. 3. I found that in practice that system doesn't work very well, it's much better to use the decimal points for making corrections as I've done here. Now let's move on. Now the next thing that happens is that the user clicks on some checkbox in the UI, which will cause an approved message to come in from the outside world. In other words, this is an event, not a message in the normal sense. So I show that it's an event in two ways. First of all the little stick figure of a person indicates that this event was initiated because of some user activity. I'm using the word user loosely here by the way, this could also be an automated subsystem. The other thing I've done is I've used a different kind of arrowhead than before, this one is a little half stick with only one line on it. Here what that means is that this is an asynchronous message. Now the word asynchronous with respect to messages can mean one of two things. Here what it means is that it comes in at a more or less random time that is outside of my control. We'll see the other use of asynchronous in a second. Now this arrowhead is also off culture with respect to the formal UML standard. In a formal UML diagram I would have used the stick arrow to mean asynchronous, but here I'm already using a stick arrow to mean synchronous so I don't want to use it in both places. So what I've done here is fallen back to an obsolete form of UML. That half arrow was part of UML, 1 but it didn't migrate into subsequent standards. However, going back to my goal here of being able to stand in front of a whiteboard and communicate the stick arrow forms are much more useful than the filled in ones, so I'll go back to the older form of arrow head. Now once the item is approved, it sends a notification up to the library, so let's draw that. Now as I'm drawing that I realize I forgot something else. I forgot to send a your comment has been approved email to the reader who posted the comment, so I'll add that now, and I'll use the decimal point like I did earlier to indicate where it goes into the sequence. Now this is an example of the other kind of asynchronous message. Notice the half arrow head. The basic idea here is that you send the message to the object, which will then do whatever you ask it to do in its own sweet time. The message handler will return immediately, but the operation won't happen until some point in the future. So that's the other kind of asynchronous message that we'll see in this kind of diagram. Now there are a few things that I haven't shown you on this picture. For one thing I could use the guards that we looked at back on the activity diagram here if I wanted to indicate that some message was only sent if some condition held. Next there are a couple more arrow types that I haven't used in this diagram that aren't used very often, but they're worth mentioning. A bulking message is one that the receiving object can refuse to accept. It's not returning an error, it's not doing anything in fact, it never saw the message. You'll see that kind of message in systems that are using formal message busses like ZeroMQ or the Azure Bus to send messages around. The next arrowhead indicates a timeout message, which is a message that is received by an object, but the object's not doing anything with it, it's just sitting on it. So the arrow with a clock over it indicates that the message has been received by some object, but it hasn't acted on it. In other words, we could return from this message handler without having actually done the thing that we are asking the object to do.

=== Sequence Diagrams
Now as I said, a collaboration diagram is by far your best choice if you're standing at a whiteboard. They're compact, they're easy to draw, they're easy to modify. There is a second sort of interaction diagram that I want to look at though, primarily because you'll see it a lot in books, so it makes sense to be able to understand it. This second diagram is a sequence diagram, and a sequence diagram really just represents exactly the same things you can represent on a collaboration diagram. Now having said that, there are a lot of details associated with sequence diagrams that I am not going to cover because you don't use them very often. What those details are, are things that are very close to the code. Things like loops and nesting relationships and nested if statements and all of that kind of stuff. As I said though, our goal here is not to draw a picture of code. We're not writing a computer program in pictures. So all of that stuff is really details that are better left to the user, or more importantly, they're details that are better expressed in the code itself, there's no point in doing that in the diagram. I should also say that sequence diagrams are indeed a little bit easier to read than collaboration diagrams, but they're a real pain to draw on a whiteboard, particularly if you have to make changes to them so I wouldn't recommend using them in front of a white board. Now, differences between sequence and collaboration diagrams, in the sequence diagram, every object is represented by a vertical line, that's called the lifeline, and it has a label on top of it that indicates the name of the object. The messages are all horizontal lines, moving from lifeline to lifeline. When an object receives a message, you can indicate that by making the lifeline wider, by putting a box on it as I've done here, and that box is called an activation. It tells us that the receiving object is busy handling the received message. The length of the box indicates how long it's busy. In other words, time moves down on this picture. Activations are optional in UML, they're annoying to draw, sometimes however, they do make the code clearer so they are worth using on occasion, but I wouldn't use them as a default. Now I'll add a few more messages, the message flow here again is identical to the collaboration diagram we were just looking at so I won't do a blow-by-blow for you. Here's a new thing though, the dashed arrow, going from right to left, indicates a return. It serves the same purpose as the tadpole that we were using in the collaboration diagram. If there's a label on the arrow, then the label indicates the name of the object that we're returning. If there's no label, well, we've just returned without returning anything in particular. Now there is one final nuance that demonstrates what activations are good for. Here I have an asynchronous message coming in while the receiving object is busy doing something else. So by using nested activations, I can indicate that there are two things going on in the same object at the same time. So the implication here is that there's some kind of threading happening. Now typically you're only going to see this in an asynchronous situation. You might see it though if there's recursion in the system. In other words, if you loop through several message calls and you eventually end up making the initial call in a recursive way, you'll see that recursion as a nested activation as well. So, now we have used an activity diagram to figure out what we're trying to do, and we have sketched out how we're going to do it, and what objects are involved with a collaboration diagram or a sequence diagram, so the next step is going to move us even closer to the code and figure out where those messages should be declared. In other words, in our next module we'll look at classes and see how the class diagrams connect to the interaction diagram.

=== Determining Class Relationships
CRC Cards and CRC-Card 'Walls'
So now we can move on to classes. It's not an accident, by the way, that I'm doing the class diagram last, that's the way you should be doing it in the real world. In other words, you're not really in a position to draw the class diagram until after you've figured out the messaging. A lot of people make a mistake and do it backwards, they try and figure out the class diagram first and the problem with that is that you waste a lot of time making guesses about how the messaging system is going to work. In other words, if you draw the class diagram first, you're just guessing on the set of messages that the class is going to have to implement. If you do an interaction diagram first, you know exactly what messages it has to implement. If an object receives a message, the class that that object is an instance of has to have the message handler in it, so by doing the messaging first, I know exactly what methods have to go into which classes. No guessing. That approach also reduces the complexity of the design quite a bit. We're not throwing stuff in here because we think we might need them for something. We're only putting things in the class diagram that are essential. The only messages that go into the class diagram, in other words, are messages that are actually used somewhere, so we end up with the simplest possible design without having to do any guesswork. Finally by working in this way, things are going to go much faster because again we're not doing guesswork, there's nothing to undo if we get it wrong. The final issue has to do with the relationships between classes. When you draw a UML class diagram you might draw inheritance relationships, we'll look at those in a few minutes. But more often than not you're drawing uses and other kinds of dependency relationships. So one of the other things that people do when they do the class diagram first is they spend a lot of time having arguments about what classes should be connected to which classes. If you do the interaction diagram first, you don't need to have that discussion. Two classes are related to each other if objects of those classes send messages to one another. It's that simple. No message, no relationship. So how do we represent the classes? The first way that I like to do this is actually another not-a-drawing drawing, I'm going to do something with index cards and a corkboard. When I'm working on a collaboration diagram I like to start guessing what the classes are, and put together something called a CRC card. CRC cards stand for Class, Responsibility, and Collaborator. They were invented by Kent Beck of extreme programming fame, and Ward Cunningham as a classroom aid for an object-oriented design class that they were doing. It turns out though, that a CRC card is a very useful thing to have around. So here's a card for the administrator class. It has the class name at the top, that's the first C, and then underneath the line I've listed the responsibilities of this class. Here an administrator is responsible for approving comments. Here's another card for the magazine class. This one is responsible for organizing articles. As I'm working on the collaboration diagram on the interaction diagram, I'll be producing these cards and I'll figure out from the messages that I'm sending what the responsibilities are. I should say, by the way, that if there are so many responsibilities that they won't fit on one card, there's something really wrong here. That's a violation of one of the SOLID principles, the so-called Single Responsibility principle, which says that a class should really do only one thing. So if I see that list of responsibilities get too long, I will split up the class into multiple classes, I'll create multiple cards with different names on them. So by the time I am done with my collaboration diagram, I'll have a stack of CRC cards and every object on the collaboration diagram must be an instance of some class that's represented by a CRC card. The opposite should hold too. There shouldn't be any CRC cards that don't map into some object that's actually doing something in some collaboration. So, I'll stick all my cards on a corkboard and I'll show the collaboration relationships with little bits of yarn that connect the collaborators, that is if an instance of class A sends a message to an instance of class B then there's going to be a piece of yarn connecting the card for class A to the card for class B. Here I'm showing that an administrator collaborates with a magazine. And now I'll add more yarn for the other classes. Now so far all of these collaboration relationships, I'm guessing, will involve some sort of field at implementation time. For example an article might contain some sort of field, which is a collection of its comments. However, you might have a uses relationship without a field. In other words, one object could be passed into another object as a method argument. There's still a uses relationship there, but you don't have a field inside the class that holds on to the thing that was passed in as an argument. Here for example, a comment talks to a magazine, but the comment object does not have a pointer to the magazine in it. So I'll use a different color. I'll use teal on the diagram in order to indicate that. Now for the vast majority of my projects I'm done at this point. My corkboard with the CRC cards on it is all of the class diagram that I need. It's showing me all of the classes in the system and it's showing me what the dependency relationships are. If I leave it on a corkboard, it's very flexible. As the system evolves I can add cards or remove cards or add bits of yarn or remove bits of yarn, so this diagram is very dynamic, but it's very easy to keep up to date. More to the point, if this corkboard is sitting in the middle of whatever room our team is working in, everybody is looking at the same class diagram all the time. If somebody goes up and makes a change to it everybody is going to notice that that's happening and complain if they don't like the change, but the point is that it's a great communication tool, a physical thing on a wall. Sometimes however, there isn't quite enough information on a corkboard, so we might want to revert to a more traditional UML class diagram. Before we start looking at that though, note that most of the decorative elements that I'll talk about in the UML class diagram go at the ends of the lines. So if I wanted to, I could just draw those decorative elements on the CRC card right next to the thumbtack that holds the piece of twine that represents the relationship.

=== UML Class-relationship Diagrams
But let's see how we would do it if we were actually drawing UML. So the first order of business is I'll turn my physical cards into a picture. Now this picture, as it stands, is quite legitimate UML. This is a UML class diagram. So my wall of cards is not that different than doing a UML class diagram. This particular diagram is a little sparse though, so let's add some more information. This arrowhead indicates that administrator objects send messages to magazine objects, but not the other way around. So administrators are dependent on magazines in the sense that if you change the definition of some method in a magazine, you may have to change the code inside the administrator class as well. Next thing I'll do is I'll put a label at the end of the line with the word library in it. That means that some object of type magazine will have the role of a library in some collaboration diagram, in some bit of code. Put another way, the labels on the ends of the line specify object names. For example here the administrator class has a field of type magazine and that field is named library. Now if you'll look back at the collaboration diagram we made in the last module you'll see that there's an object called administrator sending a message to an object called library. It is not an accident that the same names appear on both diagrams. That's how you tie the two diagrams together. We're getting awfully close to code here, so let's look at some code. Here's one possible Java implementation of an administrator. I'll show you the other classes in a moment. Alright, now moving on. The magazine is a Gang of Four singleton, a one of a kind object. I'll indicate that here with a stereotype that looks just like the ones that we used back on the story diagram. It's effectively a kind of comment that tells you something about the intent of the designer with respect to the object. As an aside, in order to make any sense at all out of the stereotype you have to know that singleton is a Gang of Four design pattern, which is to say you have to know the design patterns. As far as I'm concerned, if you're programming in an object-oriented system, knowing the design patterns is as important as knowing an object-oriented language, you really have to know them. So if you don't, as soon as you're done with this class, I strongly recommend that you go through the Design Pattern series on Pluralsight, it's really essential knowledge. Now moving back to the diagram, I'll now add some decoration to the line between the magazine and the article. Messages flow from magazines to articles, that's the arrowhead. For every one magazine, there are many articles. The star means 0 or more. The filled-in diamond represents a composition relationship, which I think of as a containment or a contains relationship. In the code, one object would actually contain another object, not a reference to an object, but the object itself. In other words, the magazine contains the articles. If the magazine is destroyed, the articles it contains should be destroyed as well. Now just for ducks, let's look at an alternative representation to this relationship. Let's get rid of the first one and replace it with this one. Here I'm saying that a magazine has a dictionary, it contains a dictionary of articles indexed by author, and the author is a person object. In other words this is effectively a hashtable. UML calls this a qualified association. So in every qualified association there are two objects involved, there is a key and a value. The object is indexed by key, and the object itself is the associated value. Now here, the qualified association version is actually more correct than the one that I replaced given that there is no direct relationship between an article and a person. That is, the article doesn't contain a field of type person, so there'd be no way to look up articles by person if you didn't have the qualified association in place. Alright, so we're done with this corner of the diagram so let's look at the code for the magazine class. Notice that I've added methods here for every one of the messages that the magazine object received in our collaboration diagram. If I wanted to, I could actually list all of those message definitions right here in the class box, either instead of or underneath the responsibilities. I don't see much point in that though. Those kinds of details are better represented in the actual code. More to the point, if I put the details in both places, both here and in the code, then every time I change the code I'd have to change this picture, and I really don't want to do that. That's just a documentation error waiting to happen. In general it's best to express something in only one place. So in my class diagrams, I list responsibilities, not individual methods. Now let's keep going. Here I've decorated the relationship between the article and comment to indicate that the articles talk to comments, but not the other way around, and there are multiple comments attached to each article. The role tells me that the article contains a field of type comment called all. This is a composition relationship, the solid diamond, so if the article is destroyed, its comments should be destroyed as well. But what about pending comments? There are lots of ways I could do that, but let's assume for now that I'm going to have second collection inside the article, which is the list of pending comments. Now the second collection should be a subset of all. Indicate that with a dashed line and the word subset inside braces. The diamond here is a hollow one, not a solid one. The hollow diamond means aggregation. An article is an aggregation of its contents and both the pending and complete set of comments. The hollow diamond though doesn't imply any kind of destruction relationship. If there's a hollow diamond and the article goes away, the pending comments are not destroyed as well. Now we need that here because the pending comments are also part of the other list so we don't want to destroy them twice. Now that's not the world's best example of aggregation so let me add another one here. Here an article has a field called author that points to one or more people. Here an article is an aggregate of its comments and its author. Because it's a hollow diamond though, if we delete the article we are not going to delete the authors, which is the right way to do things. So here is what all of this will look like in Java. Now let's flush out the comment by adding a reference to the reader who created it. Here's the UML, and here's the code. Finally I'll add a little bit of state information to the person. What I'm saying here is that the person will contain an email address and some sort of credentials that you can use for logging in. Both of these are so trivial though that I'm not going to bother to represent them with class boxes, I'll just draw them here inside of the class in its own little compartment. And here's what all of this would look like in Java.

=== Inheritance Relationships in a Class Diagram
Now so far we haven't looked at inheritance relationships. The reason for that is that inheritance is usually an implementation detail. It's just not something that occurs in an architectural level design. It's something that a programmer will decide on as he or she is implementing. So when you're designing in the way that I'm recommending here, starting with the messages and building a class diagram, you tend to not have many inheritance relationships. But, since we're talking about talking about architecture, we're talking about working at a whiteboard, we do need to discuss inheritance relationships on occasion, so here's how you would do it. Here is a simple extends relationship. A discussion is a sort of article that adds additional capabilities. Article is the superclass, discussion is the subclass, and here's the associated code. Now let's get a little more complicated, let's say that articles and discussions are independent classes that implement the same interface. I'll call that interface Post. So here the dashed lined with a hollow arrowhead represents an implements or an adopts relationship. The class that the arrow points to is the interface, or the protocol that you're adopting, and you indicate that typically with a little circle next to the name. So Post here is an interface or a protocol. Now let's add a client. Here the site is a class that contains a collection of 0 or more objects that implement Post. That collection is called content. We have no idea what the actual class is, what we do know though is that the classes will implement the Post interface. Here's the code. (Typing) Finally let's look at another variation that introduces a bit more notation. Here the article and discussion classes also implement the Post interface. This particular bit of notation is called a ball. UML doesn't use the Microsoft nomenclature so don't call it a pin. If you want to show who's using the interface you do that with the opposite of the ball, which is the socket. In other words, this is called the ball and socket notation. Now so here the site has two collections called articles and discussion. In both cases these are collections of things that implement the Post interface. At runtime, one of them will be full of article objects and the other will be full of discussion objects. The other way you could look at this notationally is that the site object talks to a discussion through the Post interface. Looking at the code, you'll see that both of the collections are defined in terms of the interfaces not in terms of the concrete classes. So that's it for classes and that's actually most of the drawings that I use. There is one more diagram that's occasionally useful though, it's one of those things that you hardly ever need it, but when you need it, you really need it, and that's a state diagram. We'll look at those in the next module.

=== Representing State-based Behavior
Mealy and Moore Machines
There's one more diagram that I want to talk about and that is the state diagram. Sometimes an object will do very different things depending on what you did with it in the past. For example, a database connection might treat a read request very differently if it's in the open state than it would if it was in the closed state. In our blogging system a comment behaves very differently when it's in the pending or unapproved state than it will when it finally moves to the approved state. And the behavior will change again if the comment is rejected and it's moved into the archived state. Now state-based behavior is usually represented by a so-called State Machine. In hardware, there are two kinds of state machines and it's worth thinking about them. In a Mealy machine, named after George Mealy, the output values are controlled by both the current state and the inputs. In a Moore machine, named after Edward, not Gordon Moore, the outputs are determined solely by its state. Now we can look at this as a kind of graph, each state could be represented by a circle, and a transition from one state to another can be shown with a line. In a Moore machine, there's some kind of activity associated with being in the state, no matter how you got there. In a Mealy machine, the activity is associated with the transition to the state. So you could have two transitions into a state for example, and the activities associated with those transitions could be different. If you think of this in terms of software, in a Moore machine, there will probably be a single method or a table somewhere that tells you what to do when you're in a particular state. In a Mealy machine, the received message will both decide what the next state is, and decide what action to perform when transitioning to that state. If you're familiar with the Gang of Four design patterns, this is exactly the problem that the state pattern is meant to solve. Now in hardware, we've got to pick one or the other of these, we can't have both at the same time, in software we can have both at the same time. So we need some kind of notation that will handle that problem and UML does a reasonably good job of that.

=== UML State Diagrams
Now all of this theory is going to make more sense when we start drawing so let's do that. I'll sketch out some of the state-based behavior associated with a comment on an article. So we'll start out with a solid dot to indicate the start state, just like I did in the activity diagram in the earlier module. The first thing we're going to do is transition from that start state to the in-progress state. In-progress means that somebody's writing the comment right now, it hasn't been approved yet. There's no particular message that moves us from the start to the in-progress state, it just happens automatically, so the line isn't labeled with anything. When our reader hits the Submit button, the comment transitions to the pending state. Now drawing in that transition, the arrow from one state to another is called an edge and the comment makes the transition when it receives a submit for approval message. Now this particular transition is a Mealy style transition, so there's an activity associated with the transition itself, notifying the administrator. Or to put it another way, that's an activity that has to happen inside the handler for the message that caused the state transition. There isn't any activity associated with the state itself, so it's possible to enter the pending state through other paths without notifying anybody. Now what if the original writer decides to edit the comment before it's been approved? In that case, some object is going to send a revise message to our comment, and the revise message will notify the writer of the article and return it to an in-progress state. This is another Mealy style edge where the activity is associated with the transition. Put another way, the object that causes us to change state will do whatever we're saying it has to do here. Now moving on, if the comment object is in the pending state and in receives an approved message it transitions to the active state. Now here we have a Moore style state. That is, there's no particular activity associated with transitioning into the active state, but we'll always do the same thing when we enter the state, no matter how we enter the state. Here, there are two state-related activities. When we enter the state, that's the word entry to the left of the slash, we'll add the comment to the user interface. When we exit this state, we'll remove the comment from the user interface. Again, it doesn't matter how we transition in or out of the state, we will always do one or the other of these activities. Now when a comment in the active state receives a delete message, it enters the archived state. It removes itself from the UI as it exits the active state, and it removes itself from the underlying data structure, the thread, as a side effect of entering the archived state. If the user hits Undo, we'll send a restore message to the comment. If we're in the archived state, the restore message will bounce us back to the active state and the comment will go back into the UI as a side effect of entering the active state. There's a reason by the way that I'm not restoring to the thread as an exit condition of the archived state, I'll get back to that in a second. Now what if we send a delete message to an object in the pending state? Now here I have both Mealy and Moore behavior. We'll remove the comment from the comment thread when we make the transition to archived. But note that we don't remove the comment from the dashboard when a pending comment is approved in the normal way. Finally, if the comment is archived, sending it a destroy message moves it into the collectable state, and once we enter that state it will be an error to send the comment any message at all. So from the collectable state, we always transition to the end state, shown as a small target icon. Now you can see why restoring the thread isn't an exit action on the archived state. If it were, we'd restore the comment to the thread as a side effect of receiving a destroy message, which I really don't want to do. So that's a state diagram. Now I have not put every possible transition, to and from every possible state, onto this diagram, and usually you don't. The general rule of thumb is that if something is not shown here it's an error if it happens, but that might not be the case all the time. You might just be drawing out a few of the more complicated states in order to make sense of them. Let's look at how we add an error condition explicitly though. What if we were to receive a destroy message for example when we're in the pending state. So here's one solution, the destroy message causes the program to abort. Note that the target here is a circle with an x in it, not with a dot in it. That means that haven't really exited the state machine in the normal way, but no further transitions are possible. We could use a similar kind of notation in an activity diagram if we wanted to, to indicate that some flow was finished, but we hadn't finished all of the activities that we want to finish. I should say again though that error transitions like this are usually just clutter. You usually don't want to put them into the diagram. So that's the complete set of UML diagrams that I want to look at, but we haven't talked about a bunch of stuff and I want to explain why and I also want to give you some references to a few resources, so I'll do that in the next module.

=== Summing up (And What's Missing)
Summing up (And What's Missing)
Summing up. I've now covered all of the notation that I use in my own work. Having said that though, there's a lot of stuff in UML in particular that I haven't talked about. First of all we need some way to represent the big picture when we're talking about architecture. We want to show how modules interact with each other for example. UML defines several diagrams for exactly that purpose, but ultimately these diagrams are no better than an informal sketch on the back of a napkin. In other words what these diagrams look like are squares with arrows pointing between the squares. Sometimes the squares have little squiggles on them to indicate what they are, but those squiggles don't carry much value. So as far as I'm concerned, the scribble on the napkin form is actually more useful than the official UML form. There's some more important issues though. Big picture architecture really isn't much different than small picture architecture. In other words, a module, a big thing, is really just a kind of coarse-grained object that talks to other modules, other coarse-grained objects, across a well-defined interface of some sort. Now we've already seen how to represent objects and classes of objects and we can apply exactly that same kind of thinking to the module level. Put it another way, the class diagram that we looked at earlier is a perfectly good way to show you the relationships between modules in the system. Now once you get out of the realm of UML, there are as many ways to draw pictures of things at the big picture level as there are architects. One architect that's done a particularly good job however is Simon Brown who has a good book on the subject. So if you want to explore big picture diagrams a little further, I'll just refer you to Simon's book. Finally, there's a lot of UML that we haven't talked about even in the diagrams that we have talked about. The formal UML spec is something like 6 inches thick when you print it. All of that extra detail though is about implementation. In other words, UML as first conceived was a way of programming in pictures, and as I said back at the beginning of things, that's really a bad idea. However, since UML was effectively a programming language, there's a lot of notation that has to do adding code level documentation. I haven't talked about any of that because, to my mind, you're better off just writing the code. My goal here is communication. I have no interest in programming in UML and then rewriting that program in Java. Consequently I don't have much interest in the notation that would tell me how to do that. That said though, if you're interested in those details and you don't want to slog through the UML specification, there is a good resource, which is Martin Fowler's UML Distilled. It does a great job, it's short, and it's definitely worth reading. Finally, if you want a reference that you can have in front of you while you're working, I have a UML reference on my personal website. If you Google UML reference, it's the first entry on the first page, but here's the URL spelled out if you want to go there directly. So that's it for the class, thank you for listening, and let me finish with an exhortation. Go forth and draw!