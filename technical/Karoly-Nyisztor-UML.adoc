= Karoly Nyisztor UML
:toc: left
:toclevels: 5
:sectnums:
:sectnumlevels: 5

NOTE: NOTE

TIP: TIP

IMPORTANT: IMPORTANT

CAUTION: CAUTION

WARNING: WARNING

[cols="1,3"]
|===
| Name | Description

| Asciidoctor
| Awesome way to write documentation

|===


== UML and Object-Oriented Design Foundations

=== Section 1: Introduction

==== Whatâ€™s Covered in this Course?

Hi, I'm Karoly Nyisztor and welcome to my course UML and Object-Oriented Design foundations. The main goal of my course is to avoid the situation when you stare at your favorite IDE without knowing what to do next. Let's first talk about the motivation behind studying UML. After learning the basic syntax of a programming language, we usually start writing some code. Eventually, we realize that creating real-world applications requires additional skills. Mastering the syntax of a programming language is not enough. *We must also know how to design the software system by applying common object-orientation principles - and we must be able to describe our design so that others can understand it clearly*. *The Unified Modelling Language provides a standard set of visual symbols and diagramming techniques. Using UML, we can sketch our systems easily*. This course is all about UML and software design related concepts. Now, the steps required to create a software system are not carved in stone. Yet, attempts have been made to formalize the process. We're going to discuss the Waterfall and the Agile approach. Object-orientation has been around since the 80s, but its principles are still valid and used in modern software design. I dedicated an entire section to the fundamental object-orientation concepts. Next, you will learn about the various steps of the object-oriented software analysis and design process. Mastering these concepts will let you design your software systems more efficiently. Then, we'll dive into UML. This UML introduction will make it easier for you to understand the upcoming detailed lectures. Next, I'll introduce the most popular UML diagram types. We start with the use case diagram that lets us describe the requirements in a formal way. Then we discuss the class diagram. Class diagrams can model the main types that form a system and the relationships between them. We'll also talk about sequence diagrams that can be used to represent the dynamic behavior of your objects. We will then discuss the activity and the state diagram. To solidify the concepts you learned, I'm going to walk you through the steps of designing a note-taking application. We'll start by collecting the requirements, and then we'll create the use case diagrams. After identifying the main entities, we'll model the class diagrams. You're also going to see the sequence and the state diagram in action. All right, we've got lots of exciting things to cover. So, let's move on.

==== Tools and Prerequisites

Now, before starting the course, you should be aware of some prerequisites. This course is beginner friendly. I explain each concept clearly and illustrate it using practical examples. So, you don't have to be an expert by any means, but you should have at least fundamental programming knowledge. I'll be using basic concepts like, for example, conditions, functions, loops, and I assume you understand them. Download *StarUML* if you want to follow along with me the creation of the UML diagrams in this course. It is available for Mac, Linux and Windows at *staruml.io*. Although we won't be writing any source code, I'll show you some code examples. I use *Atom*, a free and open source text and source code editor developed by GitHub. It is available on atom.io, and it runs on Mac OS, Linux, and Microsoft Windows. All right, let's get started.

=== Section 4: Object-Oriented Analysis and Design

==== Fundamental Object-Oriented Analysis and Design Concepts

Building an object-oriented application requires some preliminary steps. These steps are similar regardless of the development methodology. First, we need to collect the requirements. During the requirements collection phase, we answer the following questions: What's the problem we're trying to solve? What does our app or framework need to do to accomplish that functionality? The requirements collection step involves a lot of brainstorming and discussion. Once we come to an agreement, we need to document our ideas. The requirements need to be as clear as possible. Only write down the decisions that underline what the system is going to do. Vague thoughts will lead to conflicts later on. Once the requirements are clear, we come up with a description of the software system. We should describe the app from the user's perspective. Depending on the project, we may pick an Agile or a Waterfall methodology. *For Agile projects, it is completely fine if we don't provide an accurate description*. We can still fill the gaps or refine our thoughts later on. The point here is to gain as much clarity as needed to start the next step. *The step of describing the app may include the creation of visual mockups, wireframes, or even prototypes*. If it helps in communicating your thoughts to the client, then do it. *I've used wireframes and nonfunctional prototypes for most of my projects*. *These prototypes proved to be extremely useful, especially if the client was not familiar with the platform or they had no specific expectations*. Let's say a customer asks you to create an iOS version of their Android app. A prototype will help the client understand that the iOS version will look and behave differently. By communicating our vision precisely, we avoid surprises and misleading expectations. *Next comes the third phase. During this step, we aim to identify the things that form our system.* These are the potential players that have a specific, well-defined role in our application. Picking the essential entities won't be challenging if we did a good job during the previous two steps. We'll realize that we need a class that represents, say, an item that has a name, a price and some other attributes, or a class responsible for securely communicating with the server. Another class may manage your local persistence, and so on. In the final phase, we describe the behavior of our system in a formal way. This last step is about creating visual representations of our classes, their attributes and behavior. We also model the interaction between the objects. We rely on the Unified Modeling Language, or UML for short. UML is a form of graphical notation that provides a set of standard diagrams. These diagrams let us describe object-oriented systems in a standard way. I know, this may sound overwhelming now, but don't worry. We're going to discuss each of these concepts in the upcoming lectures.

==== Collecting Requirements

The initial step of building a software system is crucial. It's often called requirement-collection phase or requirements analysis. But regardless of what we call it, it paves the way for all the other phases of the object-oriented software design. Requirement means "a thing that is needed or wanted." And that's exactly what we need to focus on during this initial step: we must clarify what's needed or wanted in our application. The features of the system are the so-called functional requirements. Functional requirements represent what the app needs to provide feature-wise, how it should react to a particular input, or what the expected behavior is in a specific situation. Let's say you are about to develop an app for runners. You should answer questions like the following: Should the actual speed always be visible on the main screen? Do we allow imperial or metric units? Should we make this configurable by the user or automatically adjust the units based on the phone's settings instead? We'll also usually have non-functional requirements. These are the requirements that are not directly related to a feature or behavior of the software system, but are important nonetheless. Think of performance requirements- you don't want to ruin the user experience with an unresponsive app. You also may need to address legal requirements. Does the app collect sensitive user data? Does it allow users to browse the Internet? Documentation and support are other non-functional requirements. Your software may need to adhere to certain standards or regulations. Nonfunctional requirements are equally important. Ignoring them may cause serious legal issues and all sorts of other problems. Now, how do we handle this? There are different ways to gather the requirements. The easiest way is just to write them down. Here's an example from a project I've been working on. Functional requirements: the app must store travel expenses organized by trip. Each trip must have a home currency. The default currency is fetched from the phone's settings. User settings must override the default home currency. Expenses can be entered in any of the supported currencies. The app must automatically convert the amounts to the home currency. Nonfunctional requirements. The app must run on iOS 9 and newer versions. The app must avoid unnecessary network roundtrips to reduce data roaming fees and preserve battery. The app must include the support email and the link to the app's website. These are short, concise phrases in the form: "The app or system must do this or that." You don't want to write lengthy descriptions. And feel free to adapt this format to your needs. You should eventually capture your requirements digitally, but at early stages, pen and paper or a whiteboard are also fine. Just make sure you save them somehow - by taking a photo, for example. There are also more formal ways, tools, and systems that support the requirements collection step. I won't talk about these tools because this course is not about tools, but rather about principles. To summarize, the requirements collection step boils down to this: We need to formulate what our software must do and which are the constraints and boundaries we need to consider. If we are using a Waterfall approach, we need to clarify all the requirements in advance. For agile projects it's perfectly acceptable if we continue without having all the answers. We may even miss some of the questions. Agile lets us revisit and refine the requirements as we iterate through the software development process.

==== Mapping Requirements to Technical Descriptions

Once we have gathered the requirements, we can feed them to the next step of the software design process. This is where we provide short, accurate descriptions of our systems functionality from the user's perspective. *One way of documenting our system's features is through use cases*. A use case needs a title, something like "Create a new trip," "Add expense," or "Convert currencies." Note that each use case should represent a distinct functionality. Next, we define the actor who's using this functionality. We call it an actor since it can represent a user who's interacting with the app, but also a non-human entity like another system. Then we describe the details of this specific use case; this is called the scenario. Here, we should write one or more sentences that explain what and how the system works in this particular case. Here's an example: "Create a new trip." This is the title of our use case. The actor is the user of the mobile app. "The user can initiate the creation of a new trip from the main screen." "The title is mandatory." "All the other settings are optional." "Optionally, the user can write a short description and set a start and end date for the trip." "The app assigns a default home currency based on the phone's settings, users can override the default home currency with any of the supported currencies." "The app allows setting the budget for the trip." "The setting is optional." "Also, the user can assign a custom thumbnail to a trip." "Finally, the user can save the trip or cancel the trip creation process." *You can write this as a paragraph or as a bulleted list*. *The format doesn't really matter, but it's important to avoid technical terms. Again, this description should be understood by all stakeholders, including the end users*. The format of the use case document may vary from company to company. Some may include additional details, but that won't change the essence of it. *The use case document aims to provide a clear and human-friendly description, what a specific part of a software does and how the actors interact with it. And it is a textual description*. We'll talk about the use case diagrams later. *User stories are another common way of describing certain features or parts of our application*. User stories are shorter than use case descriptions, usually only one to two sentences long. They typically follow this format" "As a (type of user), I want - and you provide some goal - so that (some reason). Examples: "As a user, I want to add notes to my expenses so that I can identify them later on." "As a power user, I want to retrieve the app's database file so that I can inspect it on any computer." *If you can't describe the user story in one or two sentences, you may need to split it into multiple smaller user stories.* *These larger user stories are known as epics*. Epics cover a bigger chunk of functionality like in the following case: "As a traveler, I want to track my expenses while abroad so that I don't exceed my budget." This epic could be split into many other stories, including these: "As a user, I want to create new trips so that I can track each of my trips individually." "As a business traveler, I want to tag my business trips so that I can separate them from my private travels." User stories are often written on sticky notes or index cards. You will see them arranged on walls or tables during meetings and discussions. And like use case descriptions, user stories don't capture the feature details. They serve as discussion starters instead. *User stories are about communication and you will usually see them in Agile projects, whereas use case descriptions are preferable when employing Waterfall methodologies*.

==== Why Do We Need a Common Descriptive Language?

The first two steps of the object-oriented analysis don't require any special tool or design language. We only need text editing software. Even a piece of paper or a whiteboard would be sufficient to collect the requirements and jot down the use cases or user stories. The next steps require us to depict the classes that form our system, how they behave and what attributes they need. We also need to visualize how the objects interact with each other. The development community faced this very same problem. The lack of a commonly accepted design language led to the proliferation of different non-standard approaches. We could also try to come up with a way to draw everything from classes to object interactions. But luckily we don't have to. The Unified Modeling Language is a common design language that was released in 1997. UML provides a set of standard diagram types that can be used to describe both the structure and the behavior of software systems. We'll dig deeper into UML in the upcoming section.

=== Section 5: UML Basics and Fundamental Diagram Types

==== What is UML?

Understanding a software system just by looking at its source code can be very time consuming. And communicating ideas about software design or business processes is even more challenging if there is no commonly accepted way to do it. The Unified Modeling Language-in short, UML-was introduced to solve this problem. UML is not a textual programming language, but rather a graphical notation consisting of diagrams that let us model software systems. We can use these diagrams to describe the objects that form a system and their interactions. *UML has many diagram types*. We'll be discussing the most common ones: The use case diagram describes the functional model of a system - that is, the functionality of a system from the user's point of view. To describe the structure of a system, UML provides structural diagrams. We'll talk about the class diagram, which can be used to describe the structure of a system in terms of objects, attributes, operations and relations. UML let us model dynamic behavior, too. The behavioral diagrams describe the system's functionality, focusing on what happens and the interactions between objects. We'll talk about the actual diagrams shortly. The best part about UML is that it's independent of any particular programming language. We can start coding object-oriented software based on UML diagrams. If those diagrams are detailed enough, they can be converted to source code. Now, let's see some real life examples using UML. Software developers often find themselves in situations where the solution to a specific problem is not trivial or there are several different ways to tackle the problem. It may be tempting to open up your IDE and just start coding. The next thing you know, hours have disappeared and you are desperately searching StackOverflow for the answer. *However, it's hard to find a solution if we couldn't first formulate the question*. We need to figure out what to implement before writing a single line of code. That's when UML comes in handy. Whenever something is unclear, we can quickly sketch a few diagrams to represent a specific part of a software or new functionality. The benefits of this approach are twofold. First, by thinking about classes, objects and interactions, we gain a deeper understanding of what should be implemented without being distracted by crashing ideas or strange compiler error messages. Secondly, a design helps us communicate our ideas with other developers effectively. We can use UML diagrams as a starting point for discussions and improvements without having to delve into source code. Although checking the actual code is useful in many situations, it will often distract us from answering the real questions, and turn the design discussion into a code inspection. Another frequent use of UML is drawing diagrams from existing code. This technique is called reverse engineering, and it helps uncover the dirty little secrets of undocumented software systems. We can use UML to create a detailed blueprint of a system. Detailed UML blueprints are usually required for software developed using a Waterfall approach, and less frequently for Agile projects. Although UML is excellent at modeling object-oriented systems, the fact that it's platform and programming- language independent make it a versatile modeling tool that's not limited to software projects. UML has been used in multidisciplinary areas, including scientific research, transportation, banking and defense.

==== Use Case diagram

Let's start with the Use Case diagram. It's one of the simplest UML diagrams. Its purpose is to visualize the functional requirements of the system. Use Case diagrams show groups of related use cases. Sometimes they may include other use cases. The result is an overview of the system that may include several written use cases. You will rarely create Use Case diagrams for a single use case description. To represent a use case, we draw an oval in the middle of the screen and put the title of the use case in it. "Create a Trip Entry," "Edit Trip," "Export App Database" - these are examples of use cases from our travel expense app mentioned before. We use stick figures to represent the actors; as you may recall, actors are human beings or other systems that may interact with our system. We draw the stick person to the left or the right of the diagram. The actors name goes below the stick figure. We usually draw the primary actors on the left side and the secondary ones on the right side of the Use Case diagram. Next, we draw lines to represent the interaction between an actor and a use case. A mobile user can create or edit a trip entry but cannot export the app's database. The power user can perform all these actions. *We need to visualize our system's boundaries if it interacts with other systems. For that, we draw a frame around all use cases and actors that belong to a given system*. Let's say that we're relying on an external, cloud-based storage. I represent this external system as a separate actor on the right side. I even change its visual representation to show that it's not a human actor. Most tools allow you to do that. The "Create a Trip Entry" and the "Edit Trip" use cases would rely on the cloud to back up their data. So, I connect these use cases with the external system. The frame makes it obvious where our boundaries end.

Use case diagrams provide a clear way to communicate the high-level features and the scope of the system. You can quickly tell what our system does just by looking at this Use Case diagram. The system lets users create new trips and edit existing ones. Power users can even export the database. The app relies on an external cloud system to store data. Such a simple diagram makes it clear what the system does and doesn't do. A customer or a user can easily see if needed features are missing. *The absence of use cases shows what the system doesn't do*. The UML Use Case diagram includes other artifacts and relationships between use cases. We're going to ignore them as they tend to overcomplicate our design and the benefits are questionable. You can't go wrong if you focus on the actors, the use cases, and their interactions. You will be able to easily create your own Use Case diagrams and communicate your ideas in a clear and concise way. Use Case diagrams provide an easy-to-understand overview of the features of our system. *Now, keep in mind that Use Case diagrams are not a replacement for written use- case descriptions. Use case descriptions include more information to ensure that we don't miss any important details or requirements*.

==== Use Case Diagrams: Challenge

==== Use Case Diagrams: Solution

==== Class Diagrams

Without any doubt, class diagrams are the most frequently used UML diagram types. After identifying the entities that form our system, we start creating class diagrams for each of them. A class is represented on the class diagram as a rectangle with three compartments. First, we need to list the class's name. When naming our classes, we must adhere to certain rules. These rules are known as naming conventions. A class name should be a noun in the singular and it needs to start with an uppercase letter. If the name consists of multiple words, we need to uppercase each word like in this example. *The style is called Upper Camel Case*, which is Camel Case with the first letter capitalized. Camel Case is the practice of starting each word in a compound word or sentence with a capital. But why do we need rules? Why can't we just use any character sequence to name our classes? Well, we could do that. Yet, a naming convention lets us focus on important issues instead of arguing over syntax and names. With a commonly accepted set of rules, we can easily read the source code written by other developers, even if they are from another company, country or continent. Standards are useful. *All right, so our class name should be a noun in Upper Camel Case*. Let's fill the other two compartments, too. The next one lists the attributes. The attribute names should be concise and they should follow the Lower Camel Case format- that is, with the first letter lowercase and the first letters of subsequent words in uppercase. A trip has a name. It has a creation date: createdAt. It needs to have a home currency. Let's call this attribute homeCurrency. A start date-startsAt, and an end date: endsAt. It's useful to specify the type of the attribute. We can do that by writing the data type after the attribute's name separated by a colon. So here's our Trip class with the attribute names and types. The data types need to be adjusted to whatever programming language you're using. This example makes perfect sense in Swift. For Objective-C you may want to use different types, like NSString instead of String and NSDate for dates. But even if we leave it as it is, nobody will have issues understanding when we refer to a string or a date or an integer. Next comes the operations compartment. This is where we list the class's methods. *Method names should be verbs in Lower Camel Case*. We can also specify method arguments. The parameters appear within the parentheses as name-data type pairs, like in setName(value: String). To show that a method returns something, we add a colon after the closing parenthesis, followed by the return type. And we can also have methods that have arguments and a return type such as getEntries(from:) and the type is Date, to: Date and it returns a list. This list could contain multiple values or just a single value, or it could even be empty. We don't specify this in our class diagram.

==== Sequence Diagrams

Use cases and class diagrams are static diagrams. They are great at representing the structure of our system. But what if we need to show how the objects interact with each other? *When are objects created and how long are they around*? Static diagrams can't answer these questions. *UML provides dynamic diagrams to represent how objects communicate with each other*. The most common dynamic diagram is the sequence diagram. *We use the sequence diagram to describe the flow of logic in one particular scenario*. A sequence diagram starts by drawing boxes at the top of the page. Each box represents an object. Since these are objects, we name them differently: "aTrip" instead of "Trip" and "anExpense" rather than "Expense." We can also display the type after the instance's name separated by a colon. This may be helpful in some cases. The lifeline of an object is represented by *the dotted lines beneath each box*. This line shows the time the instance exists during the scenario. The sequence diagram also lets us show the messages sent from one object to the other. *A message is basically a method call*. Now let me illustrate the various messages with a practical example. I'd be using StarUML, a UML diagramming software that can be downloaded for free from www.staruml.io. Let's assume that we have a PersistenceManager object. This object is responsible for storing and retrieving entities in the app's local database. The persistence manager needs to create and store a TripEntity instance. First, I add a TripEntity object. The PersistenceManager instance sends a "create" message to initiate a TripEntity object. The "create" message is represented as a dashed line with an open arrowhead. Next, the persistence manager sends a regular message to the already created TripEntity. This message corresponds to calling the addNote() method on the TripEntity instance. A regular message is shown as a solid line with a filled arrowhead. We can add parameters to our messages if we wish. Although we could display the return message, only do it if it's important. Return messages are implicit for synchronous messages, so we don't have to display them. Asynchronous messages are drawn as solid lines with a stick arrowhead. The controller object sends an asynchronous "save" message to the persistence manager. These operations are slow, so inserting a new record into the database is a perfect opportunity for an asynchronous call. When an object sends an asynchronous message, it doesn't need to wait for a response. The asynchronous call gets executed in the background, and it returns once it completes. Unlike synchronous calls, it doesn't block the caller. Asynchronous behavior stands at the core of modern software systems. They improve responsiveness on multicore processors and provide better user experience because lengthy operations won't block the user interface. So you will probably draw async messages a lot. The issue is that the difference between regular and asynchronous messages is very subtle. Stick arrowhead instead of a filled arrowhead. To avoid misunderstandings, you can add an extra note to make clear it's an async message. We also have "self" messages. These represent a method calling another method of the same object. An object can also send a "delete" message to another object. The persistence manager sends a "delete" message to the TripEntity instance. The TripEntity gets destroyed and its lifeline gets terminated by a cross symbol. Sequence diagrams should provide an overview of what's going on in a given scenario. We don't try to represent all the method calls precisely. Instead, we focus on the most relevant parts. Sequence diagrams help us in clarifying the interactions between objects in a specific scenario. By getting more profound insights into the inner workings of our objects, we may need to refine their behavior. Or even add new classes or establish new relationships between our classes. And that's perfectly fine. The process of designing a software system is all about finding out what's missing and what needs to be enhanced or changed.

==== Activity Diagrams

In this video, I'll talk about the activity diagram. As its name suggests, the activity diagram is used to model the flow of activities in a system and the decisions that are made along the way. The activity diagram is typically used to model workflows or business processes. *For example, you might use it to model the steps that are taken to process a customer order or to create a new trip*-- more on that in a bit. In its simplest form, the activity diagram is made up of two main elements: *nodes and flows or edges*. Nodes represent actions, whereas flow lines show the flow of control between actions. We start an activity diagram with an initial node drawn as a small filled circle. We can then transition to the next node. The flow gets represented as a line that ends with an open arrowhead. The arrow points in the direction of the logic flow from one action to the other. Activity diagrams can also express conditional logic. We model a decision node as a diamond. It has a single incoming flow and two or more outbound flows. Each outbound flow has a guard, which is a Boolean condition placed inside square brackets. The guards need to be mutually exclusive. Whenever we reach a decision, we can choose only one of the outbound flows. After a decision, the flows can be merged using a merge activity. The merge activity is represented as a hollow diamond. It has two or more inbound flows and a single outbound flow. Activity diagrams support parallel behavior. *To express concurrent flows*, we use a fork drawn as a thick horizontal line. A fork has one incoming flow and several outgoing concurrent flows. *An example of actions that could be executed in parallel is storing a new order in the file system while also sending a confirmation email to the customer*. Another example that comes to mind is when you are checking out at the grocery store and the cashier is ringing up your order while another person is bagging the groceries. We need to synchronize tasks that get executed concurrently before moving on. To do that, we use a join. The join is represented as a thick horizontal line and it has two or more incoming flows and one outgoing flow. The outgoing flow gets executed after all the incoming flows have been successfully processed. Going back to our grocery store checkout example, you will leave the store after your entire order has been processed, including bagging the groceries. And of course, after you've paid for them. To indicate the end of the workflow, we use a final node. The final node is represented as a filled circle placed inside a hollow circle. Now let's look at an actual example. The following activity diagram describes a simplified version of the trip creation process. We begin with the initial node. The user decides to create a new trip. Next, the user gets prompted to enter a name for the trip. Now the app needs to check whether a trip with the same name already exists. If it does, we ask the user to enter a new name or cancel the trip creation process. If the user decides to cancel the flow, we end the activity. Otherwise, we validate the name again. If the trip name isn't taken, we let the user fill in the remaining trip data. Finally, the user hits the save button. We may also want to allow canceling the process at this point. I'll use a fork to show that we perform some actions in parallel. Storing the new trip into the local persistence and uploading it to the cloud server happens concurrently. If both actions succeed, we inform the user about the successful trip creation, and we're done. We can add more details and further actions to our activity diagram if that's useful. The activity diagram is a powerful tool for modeling workflows and business processes. While it can be complex, it is a great way to visualize the flow of actions in a system. It is especially useful for technical audiences who need to understand the inner workings of a system.

==== Statechart Diagrams

Next, we will have a look at the state chart diagram. This diagram is used to model the object's states and state transitions over its lifetime. The statechart diagram is made up of three main elements: states, transitions, and events. *The state represents the current condition of an object. For instance, a trip object might be in the "Initialized," "Edited," "Saved" or "Completed" state.* *The transition shows that an object moves from one state to another*. A transition occurs as a response to an event. When the user clicks on the Save button after editing a trip, the Trip object transitions from the "Edited" state to the "Saved" state. The statechart diagram starts with an entry point, which indicates that we're dealing with a newly created object. This initial pseudo state is represented as a filled circle that points to the trip object's initial state- "Uninitialized" in this case. States are depicted as rounded rectangles with the state's name inside, while transitions are drawn as arrows between states. The arrowhead points in the direction of the new state. Each transition has a label with an event name that triggers that transition. We can also provide a guard between brackets. A guard is a Boolean condition that must be met for the transition to occur. For example, we could add the "mandatory fields filled" guard to the "Uninitialized" to "Saved" transition. Thus, the Trip object would only transition to the "Saved" state if all mandatory fields were filled in. When the trip is successfully completed, the "Saved" state transitions to the "Completed" state. And deleting the trip will trigger the transition from "Completed" to the final state, indicating that the object has been destroyed. The statechart or state machine diagram is a powerful, yet straightforward technique for modeling the state transitions of a specific object. It can help you visualize complex state machines and avoid issues such as dead end states that are hard to spot just by looking at the source code.